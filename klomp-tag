#!/usr/bin/perl
use strict;
use warnings;

my @cols = qw(title artist album number date genre);
my $colUsage = join "|", @cols;

my $usage = "Usage:
  $0 song
     Reads tags for a variety of files and prints them
  $0 --guess=($colUsage) path-hint [value-hint]
     Does not look at the file.
     Prints a reasonable value based on the path-hint,
       or if value-hint is passed in, transliterates/normalizes/strips
       non-ascii characters
     e.g.:
       > $0 --guess=album 'The Beatles/Revolver/01-Taxman.flac'
       Revolver
       > $0 --guess=title 'Ponyo/01-深海牧場.flac' '深海牧場'
       fukami/shinkaibokujou/makiba
       > $0 --guess=date 'Nicole Atkins/Neptune City [2007]/04 Cool Enough.ogg'
       2007
  $0 [-h|--help]
      Print this usage
";

my $AUDIO_WMA = eval{ require Audio::WMA };
if(not $AUDIO_WMA){
  print STDERR "WARNING: Cannot find perl module Audio::WMA\n";
}
BEGIN{
  if(eval{ require Audio::WMA }){
    require Audio::WMA;
    Audio::WMA->import();
  }
}
  
my $TEXT_UNIDECODE = eval { require Text::Unidecode };
if(not $TEXT_UNIDECODE){
  print STDERR "WARNING: Cannot find perl module Text::Unidecode\n";
}
BEGIN{
  if(eval{ require Text::Unidecode }){
    require Text::Unidecode;
    Text::Unidecode->import;
  }
}

my $LINGUA_JA_ROMANIZE_JAPANESE =
  eval { require Lingua::JA::Romanize::Japanese };
if(not $LINGUA_JA_ROMANIZE_JAPANESE){
    print STDERR
      "WARNING: Cannot find perl module Lingua::JA::Romanize::Japanese\n";
}
BEGIN{
  if(eval { require Lingua::JA::Romanize::Japanese }){
    require Lingua::JA::Romanize::Japanese;
    Lingua::JA::Romanize::Japanese->import;
  }
}

sub guess($$$);
sub transliterateJapanese($);
sub transliterateAscii($);
sub readTags($);

sub main(@){
  die $usage if @_ == 0 or $_[0] eq '-h' or $_[0] eq '--help';
  if($_[0] =~ /^--guess=([a-z]+)$/i){
    my $col = $1;
    my %okCols = map{$_ => 1} @cols;
    die $usage if not defined $okCols{$col};

    my ($pathHint, $valueHint);
    if(@_ == 2){
      $pathHint = $_[1];
      $valueHint = '';
    }elsif(@_ ==3){
      $pathHint = $_[1];
      $valueHint = $_[2];
    }else{
      die $usage;
    }

    print guess($col, $pathHint, $valueHint) . "\n";
  }else{
    my $path = shift;
    die $usage if @_ > 0;
    my ($title, $artist, $album, $number, $date, $genre) = readTags $path;
    print ''
      . "title:$title\n"
      . "artist:$artist\n"
      . "album:$album\n"
      . "number:$number\n"
      . "date:$date\n"
      . "genre:$genre\n"
      ;
  }
}

sub guess($$$){
  my $col = shift;
  my $pathHint = shift;
  my $valueHint = shift;

  my ($filename, $innerDir, $outerDir);
  if($pathHint =~ /([^\/]*) \/ ([^\/]*) \/ ([^\/]*)$/x){
    ($filename, $innerDir, $outerDir) = ($3, $2, $1);
  }elsif($pathHint =~ /([^\/]*) \/ ([^\/]*)$/x){
    ($filename, $innerDir, $outerDir) = ($2, '', $1);
  }elsif($pathHint =~ /([^\/]*)$/x){
    ($filename, $innerDir, $outerDir) = ($1, '', '');
  }

  my $guess = '';

  if(length $valueHint > 0){
    $guess = transliterateJapanese $valueHint if $guess eq '';
    $guess = transliterateAscii $valueHint if $guess eq '';
  }else{
    if($col eq 'title'){
      $guess = $filename;
      $guess =~ s/\.[a-z0-9]{1,5}$//i;
      $guess =~ s/^[0-9 \-_]+//;
    }elsif($col eq 'artist'){
      $guess = $outerDir;
    }elsif($col eq 'album'){
      $guess = $innerDir;
    }elsif($col eq 'number'){
      if($filename =~ /^\s*(\d+)\s*/){
        $guess = $1;
      }
    }elsif($col eq 'date'){
      if($pathHint =~ /(19\d\d|20\d\d)/){
        $guess = $1;
      }
    }
  }

  return $guess;
}

sub transliterateJapanese($){
  return '' if not $LINGUA_JA_ROMANIZE_JAPANESE;
  my $arg = shift;
  if(length $arg == 0){
    return $arg;
  }
  utf8::decode($arg);
  my @parts;
  my $theRest;
  while($arg =~/
      (.*?)
      ((?:\p{Hiragana}|\p{Katakana}|\p{Han})+)
      (?=(.*$))
    /gsxi){
    my $nonjap = $1;
    my $jap = $2;
    $theRest = $3;
    my $conv = Lingua::JA::Romanize::Japanese->new();
    my $romaji = $conv->chars($jap);

    push @parts, $nonjap;
    if(not $? and defined $romaji){
      $romaji =~ s/\s+//g;
      push @parts, $romaji;
    }else{
      push @parts, $jap;
    }
  }
  utf8::encode($arg);
  if(@parts > 0){
    push @parts, $theRest;
    my $res = join '', @parts;
    utf8::encode($res);
    return $res;
  }
  return '';
}

sub transliterateAscii($){
  return '' if not $TEXT_UNIDECODE;
  my $arg = shift;
  return '' if $arg eq '';
  
  my $oldArg = $arg;

  utf8::decode($arg);
  $arg = unidecode $arg;
  utf8::encode($arg);
  
  if($oldArg eq $arg){
    return '';
  }else{
    return $arg;
  }
}

sub readTags($){
  my $file = shift;
  my $path = $file;
  $file =~ s/'/'\\''/g;

  my $title='';
  my $artist='';
  my $album='';
  my $number='';
  my $date='';
  my $genre='';
  if($file =~ /\.mp3$/i){
    my $eyeD3 = `eyeD3 --no-color '$file'`;
    $eyeD3 =~ s/\t\t/\n/g;

    $title  = $1 if $eyeD3 =~ /^title: (.*)/mi;
    $artist = $1 if $eyeD3 =~ /artist: (.*)\n/mi;
    $album  = $1 if $eyeD3 =~ /^album: (.*)$/mi;
    $number = $1 if $eyeD3 =~ /^track: (.*)$/mi;
    $date   = $1 if $eyeD3 =~ /^year: (.*)$/mi;
    $genre  = $1 if $eyeD3 =~ /^genre: (.*)$/mi;

    $genre =~ s/ \(id \d+\)$//; #trim the genre id
  }elsif($file =~ /\.(ogg|flac)$/i){
    my $lltag = `lltag -S '$file'`;
    $title  = $1 if $lltag =~ m/^\s*TITLE=(.*)$/mix;
    $artist = $1 if $lltag =~ m/^\s*ARTIST=(.*)$/mix;
    $album  = $1 if $lltag =~ m/^\s*ALBUM=(.*)$/mix;
    $number = $1 if $lltag =~ m/^\s*NUMBER=(.*)$/mix;
    $date   = $1 if $lltag =~ m/^\s*DATE=(.*)$/mix;
    $genre  = $1 if $lltag =~ m/^\s*GENRE=(.*)$/mix;
  }elsif($file =~ /\.(wma)$/i){
    my %tags;
    if($AUDIO_WMA){
      my $wma  = Audio::WMA->new($path);
      %tags = %{$wma->tags()};
    }else{
      print STDERR "WARNING: no tags for $file, missing Audio::WMA\n";
    }

    for my $tag(keys %tags) {
      $title  = $tags{$tag} if $tag =~ m/^TITLE$/mix;
      $artist = $tags{$tag} if $tag =~ m/^ALBUMARTIST$/mix;
      $artist = $tags{$tag} if $tag =~ m/^AUTHOR$/mix;
      $album  = $tags{$tag} if $tag =~ m/^ALBUMTITLE$/mix;
      $number = $tags{$tag} if $tag =~ m/^TRACKNUMBER$/mix;
      $date   = $tags{$tag} if $tag =~ m/^YEAR$/mix;
      $genre  = $tags{$tag} if $tag =~ m/^GENRE$/mix;
    }
  }elsif($file =~ /\.(mp4|m4a|m4p|m4v|m4b)$/i){
    my $atomic = `AtomicParsley '$file' -t`;
    $title  = $1 if $atomic =~ m/^Atom\ "©NAM"\ contains:\ (.*)$/mix;
    $artist = $1 if $atomic =~ m/^Atom\ "©ART"\ contains:\ (.*)$/mix;
    $album  = $1 if $atomic =~ m/^Atom\ "©ALB"\ contains:\ (.*)$/mix;
    $number = $1 if $atomic =~ m/^Atom\ "trkn"\ contains:\ (.*)$/mix;
    $date   = $1 if $atomic =~ m/^Atom\ "©day"\ contains:\ (.*)$/mix;
    $genre  = $1 if $atomic =~ m/^Atom\ "(?:gnre|©gen)"\ contains:\ (.*)$/mix;
  }elsif($file =~ /\.wav$/i){
    #so wavs apparently have RIFF tags, but ive never seen em
  }else{
    print STDERR "Not a filetype we know how to read tags from: $path";
  }

  return ($title, $artist, $album, $number, $date, $genre);
}

&main(@ARGV);
