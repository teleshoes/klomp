#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(dirname basename);
use Time::HiRes qw(time);

my $EXEC = basename $0;

sub getFileInfo($@);
sub getRelFiles($$);
sub execCommands($@);
sub nowMillis();

my $usage = "Usage:
  $0 [[USER\@]HOST:]SRC_DIR [[USER\@]HOST:]DEST_DIR
    SRC and DEST can be remote or local.
    Script will compare DEST to SRC, find files that are similar in DEST
    but in a different relative location, and move them to match. It will
    create subdirs in DEST as necessary to move the files, but will never
    replace existing files or rm files or directories.
    e.g.:
    presync src/ dest/
      src/one/a           =>    src/one/a
      src/one/b           =>    src/one/b
      src/one/c           =>    src/one/c
      src/two/d           =>    src/two/d
      src/two/e           =>    src/two/e
      src/two/f           =>    src/two/f

      dest/a              =>    dest/one/a
      dest/b              =>    dest/one/b
      dest/c              =>    dest/one/c
      dest/d              =>    dest/d
      dest/bananacake/e   =>    dest/two/e
      dest/two/d          =>    dest/two/d
                          =>    dest/bananacake/
";

sub main(@){
  die $usage if @_ != 2;
  my ($src, $dest) = @_;

  my ($srcHost, $srcDir);
  if(-d $src){
    ($srcHost, $srcDir) = (undef, $src);
  }elsif($src =~ /^((?:.+@)?.+):(.*)$/){
    ($srcHost, $srcDir) = ($1, $2);
  }else{
    die "$src must be a local or remote dir\n";
  }

  my ($destHost, $destDir);
  if(-d $dest){
    ($destHost, $destDir) = (undef, $dest);
  }elsif($dest =~ /^((?:.+@)?.+):(.*)$/){
    ($destHost, $destDir) = ($1, $2);
  }else{
    die "$dest must be a local or remote dir\n";
  }

  $srcDir =~ s/\/+$//;
  $destDir =~ s/\/+$//;

  my %srcRelFiles = map {$_ => 1} getRelFiles($srcHost, $srcDir);
  my %destRelFiles = map {$_ => 1} getRelFiles($destHost, $destDir);

  my @added = grep {not defined $srcRelFiles{$_}} sort keys %destRelFiles;
  my @missing = grep {not defined $destRelFiles{$_}} sort keys %srcRelFiles;

  my $addedInfo = getFileInfo($destHost, $destDir, @added);
  my $missingInfo = getFileInfo($srcHost, $srcDir, @missing);

  my %fileMoves;
  for my $destRelFile(@added){
    my $destInfo = $$addedInfo{$destRelFile};
    if(not defined $destInfo){
      die "ERROR: stat did not find $destRelFile on dest\n";
    }
    for my $srcRelFile(@missing){
      my $srcInfo = $$missingInfo{$srcRelFile};
      if(not defined $srcInfo){
        die "ERROR: stat did not find $srcRelFile on src\n";
      }
      if($$srcInfo{fsize} == $$destInfo{fsize} and $$srcInfo{mtime} == $$destInfo{mtime}){
        $fileMoves{$destRelFile} = $srcRelFile;
        last;
      }
    }
  }


  my @mvCommands;
  for my $destRelFile(sort keys %fileMoves){
    my $srcRelFile = $fileMoves{$destRelFile};

    my $dir = $destDir;
    $dir =~ s/'/'\\''/g;

    my $relDirname = dirname $srcRelFile;
    $relDirname =~ s/'/'\\''/g;
    push @mvCommands, "mkdir -p '$dir/$relDirname'";

    $destRelFile =~ s/'/'\\''/g;
    $srcRelFile =~ s/'/'\\''/g;
    push @mvCommands, "mv --no-clobber '$dir/$destRelFile' '$dir/$srcRelFile'";
  }

  print "RUNNING:\n";
  print "$_\n" foreach @mvCommands;

  print execCommands $destHost, @mvCommands;
}

sub getFileInfo($@){
  my ($host, $dir, @relFiles) = @_;
  my @cmds;
  for my $relFile(@relFiles){
    my $file = "$dir/$relFile";
    $file =~ s/'/'\\''/g;
    push @cmds, "stat -c '%s_%Y_%n' '$file'";
  }
  my @statLines = split /\n/, execCommands($host, @cmds);
  my $info = {};
  for my $line(@statLines){
    if($line =~ /^(\d+)_(\d+)_(.+)$/){
      my ($fsize, $mtime, $file) = ($1, $2, $3);
      my $relFile;
      if($file =~ /^$dir\/(.+)$/){
        $relFile = $1;
      }else{
        die "ERROR: malformed output from stat command: $line\n";
      }
      $$info{$relFile} = {fsize => $fsize, mtime => $mtime};
    }else{
      die "ERROR: malformed output from stat command: $line\n";
    }
  }
  return $info;
}

sub getRelFiles($$){
  my ($host, $dir) = @_;

  $dir =~ s/'/'\\''/g;

  my $cmd = "find '$dir/' -type f";
  $cmd = "ssh $host $cmd" if defined $host;

  my @files = `$cmd`;

  my @relFiles;
  for my $file(@files){
    if($file =~ /^$dir\/(.+)$/){
      push @relFiles, $1;
    }else{
      die "ERROR: malformed find output $file\n";
    }
  }

  return @relFiles;
}

sub execCommands($@){
  my ($host, @commands) = @_;

  my $tmpOutFile = "/tmp/$EXEC-out-" . nowMillis();

  if(defined $host){
    open CMD, "|-", "ssh $host bash >$tmpOutFile 2>&1";
  }else{
    open CMD, "|-", "bash >$tmpOutFile 2>&1";
  }
  for my $cmd(@commands){
    print CMD "$cmd\n";
  }
  print CMD "exit;\n";
  close CMD;

  my $out = `cat $tmpOutFile`;
  system "rm", $tmpOutFile;

  return $out;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
