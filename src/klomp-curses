#!/usr/bin/python
import curses
import curses.textpad
import time
import sys
import os
import subprocess
import threading
import csv

import locale
locale.setlocale(locale.LC_ALL,"")

uiLock = threading.RLock()

klompList = os.environ['HOME'] + "/.klomplist"

def main(args):
  sys.setrecursionlimit(100000) #HACK BUG WORKAROUND FUCKERS
  try:
    curses.wrapper(KlompUI().start)
  finally:
    if not(len(args) == 2 and args[1] == "--debug"):
      os._exit(0)
    os.system("rm out")

def msg(s):
  os.system("echo '" + str(s) + "' >> out")

def readProc(cmdArr):
  out, err = subprocess.Popen(cmdArr, stdout=subprocess.PIPE).communicate()
  return out

class KeyReaderThread(threading.Thread):
  def __init__(self, stdscr, onGetSomeKeys):
    threading.Thread.__init__(self)
    self.stdscr = stdscr
    self.onGetSomeKeys = onGetSomeKeys
  def run(self):
    while True:
      keys = self.getSomeKeysBlocking()
      self.onGetSomeKeys(keys)
  def getch(self):
    key = self.stdscr.getch()
    return curses.KEY_ENTER if key == ord('\n') else key
  def getSomeKeysBlocking(self):
    keys = []

    self.stdscr.nodelay(0)
    keys.append(self.getch())

    self.stdscr.nodelay(1)
    while True:
      key = self.getch()
      if key == -1:
        break
      keys.append(key)
    return keys

class LinePrinter():
  def __init__(self, height, width, y, x):
    self.line = 0
    self.y = y
    self.x = x
    self.height = height
    self.width = width
    self.win = curses.newwin(height, width, y, x)
  def updateSize(self):
    y, x = self.win.getmaxyx()
    self.height, self.width = y - self.y, x - self.x
  def isWindowFull(self):
    return self.line >= self.height
  def printLine(self, msg):
    try:
      self.win.addstr(self.line, 0, msg)
    except curses.error:
      pass
    self.line += 1
  def clear(self):
    self.win.erase()
    self.line = 0

class TextEdit(LinePrinter):
  def __init__(self, line, width, onCommandKey):
    LinePrinter.__init__(self, 1, width, line, 0)
    self.onCommandKey = onCommandKey
    self.preText = u""
    self.postText = u""
  def handleKeys(self, keys):
    text = ""
    cmds = []
    for key in keys:
      c = curses
      if key in [c.KEY_ENTER, c.KEY_UP, c.KEY_DOWN, c.KEY_PPAGE, c.KEY_NPAGE]:
        cmds.append(key)
      elif key == c.KEY_HOME:
        self.postText = self.preText + self.postText
        self.preText = u""
      elif key == c.KEY_END:
        self.preText += self.postText
        self.postText = u""
      elif key == c.KEY_LEFT:
        self.postText = self.preText[-1:] + self.postText
        self.preText = self.preText[:-1]
      elif key == c.KEY_RIGHT:
        self.preText += self.postText[:1]
        self.postText = self.postText[1:]
      elif key == c.KEY_BACKSPACE:
        self.preText = self.preText[:-1]
      elif key == c.KEY_DC: #delete
        self.postText = self.postText[1:]
      elif key < 256:
        text += chr(key)
    self.preText += text.decode('utf8')
    for key in cmds:
      self.onCommandKey(key)
  def getCursorPos(self):
    length = len(self.preText)
    tabwidth = 8
    tabstop = 0
    for c in self.preText:
      tabstop = 1 + (tabstop % tabwidth)
      if c == "\t":
        length += tabwidth-tabstop
        tabstop = 0
      elif self.isFullWidth(c):
        length += 1
        tabstop += 1
    return length
  def isFullWidth(self, c):
    p = ord(c)
    return (False
       or (p >= 0x3041 and p <= 0xfa2d)
       or (p >= 0xfe30 and p <= 0xfe6b)
       or (p >= 0xff01 and p <= 0xff60)
       or (p >= 0xffe0 and p <= 0xffee)
    )
  def getText(self):
    return self.preText.encode('utf8') + self.postText.encode('utf8')
  def updateText(self):
    self.clear()
    self.printLine(self.getText())
    self.win.noutrefresh()
  def updateCursor(self):
    pos = self.getCursorPos()
    self.win.move(0, pos)
    curses.setsyx(self.y, pos)

class Prompt(LinePrinter):
  def __init__(self, height, width):
    LinePrinter.__init__(self, height, width, 2, 0)
    self.shuffle = True
  def setTmpFile(self, tmpFile):
    self.tmpFile = tmpFile
  def setSongCount(self, songCount):
    self.songCount = songCount
  def update(self):
    self.clear()
    map(self.printLine, [
      "wrote %d files to %s" % (self.songCount, self.tmpFile),
      "",
      "enter - prepend files to KLOMPLIST",
      "a     - append files to KLOMPLIST",
      "o     - overwrite KLOMPLIST with files",
      "  notyet:"
      "  s     - intersperse files into KLOMPLIST, keeps order unless shuffle",
      "  r     - REMOVE these files from KLOMPLIST",
      "",
      "shuffle => " + str(self.shuffle) + "  {space to toggle}"])
    self.win.noutrefresh()
  def maybeShuffleTmpFile(self):
    if self.shuffle:
      os.system("sort -R " + self.tmpFile + " -o " + self.tmpFile)
  def appendTmpFile(self):
    os.system("cat " + self.tmpFile + " >> " + klompList)
  def prependTmpFile(self):
    os.system("cat " + klompList + " >> " + self.tmpFile)
    self.replaceTmpFile()
  def replaceTmpFile(self):
    os.system("mv " + self.tmpFile + " " + klompList)
  def handleKeys(self, keys):
    c = curses
    for key in keys:
      if key == c.KEY_ENTER:
        self.maybeShuffleTmpFile()
        self.prependTmpFile()
        return True
      elif key == ord('a'):
        self.maybeShuffleTmpFile()
        self.appendTmpFile()
        return True
      elif key == ord('o'):
        self.maybeShuffleTmpFile()
        self.replaceTmpFile()
        return True
      elif key == ord(' '):
        self.shuffle = not self.shuffle
    return False

class SongDisplay(LinePrinter):
  def __init__(self, height, width):
    LinePrinter.__init__(self, height, width, 1, 0)
    self.offset = 0
  def setSongs(self, songs):
    self.songs = songs
  def getSongEntries(self, query):
    entries = []
    sep = "///\\\\\\"
    libPaths = {}
    for s in self.songs:
      lib = s['library']
      if lib not in libPaths:
        libPaths[lib] = readProc(["klomp-lib", "-l", lib]).rstrip()
      path = libPaths[lib] + "/" + s['relpath']
      entries.append(
        path +
        sep + "artist=" + s['artist'] +
        sep + "album=" + s['album'] +
        sep + "number=" + s['number'] +
        sep + "title=" + s['title'] +
        sep + "query=" + query + "\n")
    return entries
  def addOffset(self, offset):
    prevOffset = self.offset
    self.offset += offset
    
    limit = len(self.songs) - self.height/3
    limit = 0 if limit < 0 else limit
    if self.offset < 0:
      self.offset = 0
    elif self.offset > limit:
      self.offset = limit

    return self.offset != prevOffset
  def getSongBucket(self, s):
    return s['artist'] + '###' + s['album'] + '###' + s['library']
  def trimMid(self, s, lim, ellip):
    length = len(s)
    if length <= lim:
      return s
    else:
      ellipLen = len(ellip.decode('utf8'))
      left = lim/2
      right = length - lim/2 - lim%2 + ellipLen
      return s[:left] + ellip + s[right:]
  def padNumbers(self, songs):
    maxLen = max([len(s['number']) for s in songs])
    for s in songs:
      numLen = len(s['number'])
      prefix = ('0' if numLen > 0 else ' ') * (maxLen - numLen)
      s['number'] = prefix + s['number']
  def formatSong(self, s):
    return ' ' + s['number'] + ':' + s['title']
  def formatSongBucket(self, s):
    prefix = ''
    sep1 = ' - '
    sep2 = ' ('
    suffix = ')'
    lib = s['library']
    limit = self.width - len(prefix + sep1 + sep2 + lib + suffix)
    artistLimit = limit/2 + limit%2
    albumLimit = limit/2
    artistLen = len(s['artist'])
    albumLen = len(s['album'])
    if artistLimit > artistLen:
      albumLimit += artistLimit - artistLen
      artistLimit = artistLen
    if albumLimit > albumLen:
      artistLimit += albumLimit - albumLen
      albumLimit = albumLen

    ellip = unichr(8230).encode('utf8') #HORIZONTAL ELLIPSIS
    artist = self.trimMid(s['artist'], artistLimit, ellip)
    album = self.trimMid(s['album'], albumLimit, ellip)
    return prefix + artist + sep1 + album + sep2 + lib + suffix
  def getSummary(self, songs):
    songLen = 0
    artists = dict()
    albums = dict()
    libs = dict()

    for s in songs:
      if s['artist'] not in artists:
        artists[s['artist']] = True
      if s['album'] not in albums:
        albums[s['album']] = True
      if s['library'] not in libs:
        libs[s['artist']] = True
      songLen += 1
    return "%d Songs  %d Artists  %d Albums" % (
      songLen, len(artists), len(albums))
  def getOffsetDisplay(self):
    return '' if self.offset == 0 else " offset=%d" % self.offset
  def update(self):
    self.clear()
    self.updateSize()
 
    buckets = dict()
    bucketDisplays = dict()
    bucketOrder = []

    self.addOffset(0)
    count = 0
    limit = self.height - 1
    for song in self.songs[self.offset:self.offset+limit]:
      b = self.getSongBucket(song)
      if b not in buckets:
        buckets[b] = []
        bucketDisplays[b] = self.formatSongBucket(song)
        bucketOrder.append(b)
      buckets[b].append(song)

    self.printLine(self.getSummary(self.songs) + self.getOffsetDisplay())
    for bucket in bucketOrder:
      if self.isWindowFull():
        break
      self.printLine(bucketDisplays[bucket])
      bucketSongs = buckets[bucket]
      self.padNumbers(bucketSongs)
      for fmtSong in [self.formatSong(s) for s in bucketSongs]:
        self.printLine(fmtSong)
    self.win.noutrefresh()

class KlompQuery():
  def __init__(self):
    self.cols = ['artist', 'album', 'number', 'title', 'relpath', 'library']
    self.query = None
  def buildQueryCmd(self):
    cmd = ["klomp-db", "-s", self.query]
    for col in self.cols:
      cmd.append("--col")
      cmd.append(col)
    return cmd
  def parseCsv(self, string, colNames):
    return list(csv.DictReader(string.split("\n"), fieldnames=colNames,
      delimiter=',', quotechar='"'))
  def maybePerformQuery(self, query):
    if self.query != query:
      self.query = query
      return self.performQuery()
    else:
      return None
  def performQuery(self):
    return self.parseCsv(readProc(self.buildQueryCmd()), self.cols)

class KlompUI():
  def __init__(self):
    self.klompQuery = KlompQuery()
    self.promptMode = False
  def start(self, stdscr):
    self.stdscr = stdscr
    height, width = self.stdscr.getmaxyx()
    self.textEdit = TextEdit(0, width, self.onCommandKey)
    self.songDisplay = SongDisplay(height, width)
    self.prompt = Prompt(height, width)
    KeyReaderThread(self.stdscr, self.onGetSomeKeys).start()
    while True:
      if not self.promptMode:
        self.updateSongs()
      time.sleep(1)
  def updateSongs(self):
    songs = self.klompQuery.maybePerformQuery(self.textEdit.getText())
    if songs != None:
      self.songDisplay.setSongs(songs)
      self.updateSongDisplay()
  def setupPrompt(self):
    self.promptMode = True
    self.updateSongs()
    ms = int(round(time.time() * 1000))
    tmpFile = "/tmp/klomplist_" + str(ms)

    songEntries = self.songDisplay.getSongEntries(self.klompQuery.query)
    with open(tmpFile, 'w') as f:
      f.writelines(songEntries)
    self.prompt.setTmpFile(tmpFile)
    self.prompt.setSongCount(len(songEntries))
    self.clear()
    self.updatePrompt()
  def onCommandKey(self, key):
    c = curses
    offsetKeys = {
      c.KEY_UP: -1,
      c.KEY_DOWN: 1,
      c.KEY_PPAGE: -10,
      c.KEY_NPAGE: 10}

    if key == c.KEY_ENTER:
      self.setupPrompt()
    elif key in offsetKeys:
      if self.songDisplay.addOffset(offsetKeys[key]):
        self.updateSongDisplay()
  def onGetSomeKeys(self, keys):
    if self.promptMode:
      if self.prompt.handleKeys(keys):
        self.promptMode = False
        self.clear()
        self.updateSongDisplay()
        self.updateTextEditDisplay()
      else:
        self.updatePrompt()
    else:
      self.textEdit.handleKeys(keys)
      self.updateTextEditDisplay()
  def clear(self):
    with uiLock:
      self.textEdit.clear()
      self.songDisplay.clear()
      self.prompt.clear()
  def updateTextEditDisplay(self):
    with uiLock:
      self.textEdit.updateText()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updateSongDisplay(self):
    with uiLock:
      self.songDisplay.update()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updatePrompt(self):
    with uiLock:
      self.prompt.update()
      curses.doupdate()

if __name__ == "__main__":
  main(sys.argv)
