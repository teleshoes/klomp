#!/usr/bin/python
import curses
import curses.textpad
import time
import sys
import os
import subprocess
import threading
import csv

import locale
locale.setlocale(locale.LC_ALL,"")

lock = threading.RLock()

def msg(s):
  os.system("echo '" + str(s) + "' >> out")

class KeyReader(threading.Thread):
  def __init__(self, stdscr, onKeyPressed):
    threading.Thread.__init__(self)
    self.stdscr = stdscr
    self.keys = []
    self.onKeyPressed = onKeyPressed
  def run(self):
    while True:
      self.readNextKeyBlocking()
      self.readAllAvailableKeys()
      self.onKeyPressed()
  def readNextKeyBlocking(self):
    self.stdscr.nodelay(0)
    self.appendKey(self.stdscr.getch())
  def readAllAvailableKeys(self):
    self.stdscr.nodelay(1)
    key = self.stdscr.getch()
    while key != -1:
      msg(key)
      self.appendKey(key)
      key = self.stdscr.getch()
  def appendKey(self, key):
    with lock:
      self.keys.append(key)
  def grabKeys(self):
    with lock:
      keys = self.keys
      self.keys = []
      return keys

class LineEditor():
  def __init__(self, line, width):
    self.preText = u""
    self.postText = u""
    self.line = line
    self.win = curses.newwin(1,width,line,0)
  def handleKeys(self, keys):
    text = ""
    for key in keys:
      if key == curses.KEY_ENTER or key == 10:
        msg(key)
      elif key == curses.KEY_HOME:
        self.postText = self.preText + self.postText
        self.preText = u""
      elif key == curses.KEY_END:
        self.preText += self.postText
        self.postText = u""
      elif key == curses.KEY_LEFT:
        self.postText = self.preText[-1:] + self.postText
        self.preText = self.preText[:-1]
      elif key == curses.KEY_RIGHT:
        self.preText += self.postText[:1]
        self.postText = self.postText[1:]
      elif key == curses.KEY_BACKSPACE:
        self.preText = self.preText[:-1]
      elif key == curses.KEY_DC: #delete
        self.postText = self.postText[1:]
      elif key < 256:
        text += chr(key)
    self.preText += text.decode('utf8')
  def getCursorPos(self):
    length = len(self.preText)
    tabwidth = 8
    tabstop = 0
    for c in self.preText:
      tabstop = 1 + (tabstop % tabwidth)
      if c == "\t":
        length += tabwidth-tabstop
        tabstop = 0
      elif self.isFullWidth(c):
        length += 1
        tabstop += 1
    return length
  def isFullWidth(self, c):
    p = ord(c)
    if (False
       or (p >= 0x3041 and p <= 0xfa2d)
       or (p >= 0xfe30 and p <= 0xfe6b)
       or (p >= 0xff01 and p <= 0xff60)
       or (p >= 0xffe0 and p <= 0xffee)
       ):
      return True
    else:
      return False
  def getText(self):
    return self.preText.encode('utf8') + self.postText.encode('utf8')
  def updateText(self):
    self.win.erase()
    self.win.addstr(0, 0, self.getText())
    self.win.noutrefresh()
  def updateCursor(self):
    pos = self.getCursorPos()
    self.win.move(self.line, pos)
    curses.setsyx(self.line, pos)

class SongDisplay():
  def __init__(self, height, width):
    self.height = height
    self.width = width
    self.win = curses.newwin(height-1,width,1,0)
  def clear(self):
    self.win.erase()
    self.line = 0
  def screenFull(self):
    return self.line >= self.height
  def printLine(self, msg):
    addstr(self.win, self.line, 0, msg)
    self.line += 1
  def getSongBucket(self, s):
    return s['artist'] + '###' + s['album'] + '###' + s['library']
  def trimMid(self, s, lim, ellip):
    length = len(s)
    if length <= lim:
      return s
    else:
      ellipLen = len(ellip.decode('utf8'))
      left = lim/2
      right = length - lim/2 - lim%2 + ellipLen
      return s[:left] + ellip + s[right:]
  def formatSong(self, s):
    return ' ' + s['number'] + ':' + s['title']
  def formatSongBucket(self, s):
    prefix = ''
    sep1 = ' - '
    sep2 = ' ('
    suffix = ')'
    lib = s['library']
    limit = self.width - len(prefix + sep1 + sep2 + lib + suffix)
    artistLimit = limit/2 + limit%2
    albumLimit = limit/2
    artistLen = len(s['artist'])
    albumLen = len(s['album'])
    if artistLimit > artistLen:
      albumLimit += artistLimit - artistLen
      artistLimit = artistLen
    if albumLimit > albumLen:
      artistLimit += albumLimit - albumLen
      albumLimit = albumLen

    ellip = unichr(8230).encode('utf8') #HORIZONTAL ELLIPSIS
    artist = self.trimMid(s['artist'], artistLimit, ellip)
    album = self.trimMid(s['album'], albumLimit, ellip)
    return prefix + artist + sep1 + album + sep2 + lib + suffix
  def getSummary(self, songs):
    songLen = 0
    artists = dict()
    albums = dict()
    libs = dict()

    for s in songs:
      if s['artist'] not in artists:
        artists[s['artist']] = True
      if s['album'] not in albums:
        albums[s['album']] = True
      if s['library'] not in libs:
        libs[s['artist']] = True
      songLen += 1
    return "%d Songs  %d Artists  %d Albums" %(songLen, len(artists), len(albums))
  def update(self, songs):
    self.clear()
 
    buckets = dict()
    bucketDisplays = dict()
    bucketOrder = []

    count = 0
    limit = self.height - 1
    for song in songs[:limit]:
      b = self.getSongBucket(song)
      if b not in buckets:
        buckets[b] = []
        bucketDisplays[b] = self.formatSongBucket(song)
        bucketOrder.append(b)
      buckets[b].append(song)

    self.printLine(self.getSummary(songs))
    for bucket in bucketOrder:
      if self.screenFull():
        break
      self.printLine(bucketDisplays[bucket])
      for song in buckets[bucket]:
        self.printLine(self.formatSong(song))
    self.win.noutrefresh()

def readProc(cmdArr):
  out, err = subprocess.Popen(cmdArr, stdout=subprocess.PIPE).communicate()
  return out

def klompQuery(q):
  cols = ['artist', 'album', 'number', 'title', 'relpath', 'library']
  cmd = ["klomp-db", "-s", q]
  for col in cols:
    cmd.append("--col")
    cmd.append(col)
  lines = readProc(cmd).split("\n")
  return csv.DictReader(lines, fieldnames=cols, delimiter=',', quotechar='"')

class KlompUI():
  def __init__(self, stdscr, initialQuery=''):
    self.height = stdscr.getmaxyx()[0]
    self.width = stdscr.getmaxyx()[1]
    self.lineEditor = LineEditor(0, self.width)
    self.songDisplay = SongDisplay(self.height, self.width)
    self.lastQuery = None
    self.keyReader = KeyReader(stdscr, self.updateLineEditor)
    self.keyReader.start()
    if initialQuery != None and len(initialQuery) > 0:
      self.lineEditor.preText = initialQuery
      self.updateLineEditor()
  def checkQuery(self):
    old = self.lastQuery
    self.lastQuery = self.lineEditor.getText()
    if self.lastQuery != old:
      self.performQuery()
  def performQuery(self):
    self.songs = klompQuery(self.lastQuery)
    with lock:
      self.songDisplay.update(self.songs)
      self.lineEditor.updateCursor()
      curses.doupdate()
  def updateLineEditor(self):
    self.lineEditor.handleKeys(self.keyReader.grabKeys())
    with lock:
      self.lineEditor.updateText()
      self.lineEditor.updateCursor()
      curses.doupdate()


if __name__ == "__main__":
  stdscr = curses.initscr()
  curses.noecho()
  curses.cbreak()
  stdscr.keypad(1)
  try:
    sys.setrecursionlimit(100000) #HACK BUG WORKAROUND FUCKERS
    os.system("rm out")
    if len(sys.argv) > 1:
      q = sys.argv[1].decode('utf8')
    else:
      q = ''
    klompUI = KlompUI(stdscr, q)
    while True:
      klompUI.checkQuery()
      time.sleep(1)
  finally:
    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
    curses.endwin()
    os._exit(0)
