#!/usr/bin/python
import curses
import curses.textpad
import time
import sys
import os
import subprocess
import threading
import csv

import locale
locale.setlocale(locale.LC_ALL,"")

uiLock = threading.RLock()

def main(args):
  sys.setrecursionlimit(100000) #HACK BUG WORKAROUND FUCKERS
  try:
    curses.wrapper(KlompUI().start)
  finally:
    os._exit(0)
    os.system("rm out")

def msg(s):
  os.system("echo '" + str(s) + "' >> out")

def addstr(win, y, x, s):
  try:
    win.addstr(y, x, s)
  except curses.error:
    pass

class KeyReaderThread(threading.Thread):
  def __init__(self, stdscr, onGetSomeKeys):
    threading.Thread.__init__(self)
    self.stdscr = stdscr
    self.onGetSomeKeys = onGetSomeKeys
  def run(self):
    while True:
      keys = self.getSomeKeysBlocking()
      self.onGetSomeKeys(keys)
  def getSomeKeysBlocking(self):
    keys = []

    self.stdscr.nodelay(0)
    keys.append(self.stdscr.getch())

    self.stdscr.nodelay(1)
    while True:
      key = self.stdscr.getch()
      if key == -1:
        break
      keys.append(key)
    return keys

class LineEditor():
  def __init__(self, line, width, onCommandKey):
    self.line = line
    self.width = width
    self.onCommandKey = onCommandKey
    self.win = curses.newwin(1, self.width, self.line, 0)
    self.preText = u""
    self.postText = u""
  def handleKeys(self, keys):
    text = ""
    for key in keys:
      c = curses
      key = c.KEY_ENTER if key == 10 else key

      if key in [c.KEY_ENTER, c.KEY_UP, c.KEY_DOWN, c.KEY_PPAGE, c.KEY_NPAGE]:
        self.onCommandKey(key)
      elif key == c.KEY_HOME:
        self.postText = self.preText + self.postText
        self.preText = u""
      elif key == c.KEY_END:
        self.preText += self.postText
        self.postText = u""
      elif key == c.KEY_LEFT:
        self.postText = self.preText[-1:] + self.postText
        self.preText = self.preText[:-1]
      elif key == c.KEY_RIGHT:
        self.preText += self.postText[:1]
        self.postText = self.postText[1:]
      elif key == c.KEY_BACKSPACE:
        self.preText = self.preText[:-1]
      elif key == c.KEY_DC: #delete
        self.postText = self.postText[1:]
      elif key < 256:
        text += chr(key)
    self.preText += text.decode('utf8')
  def getCursorPos(self):
    length = len(self.preText)
    tabwidth = 8
    tabstop = 0
    for c in self.preText:
      tabstop = 1 + (tabstop % tabwidth)
      if c == "\t":
        length += tabwidth-tabstop
        tabstop = 0
      elif self.isFullWidth(c):
        length += 1
        tabstop += 1
    return length
  def isFullWidth(self, c):
    p = ord(c)
    return (False
       or (p >= 0x3041 and p <= 0xfa2d)
       or (p >= 0xfe30 and p <= 0xfe6b)
       or (p >= 0xff01 and p <= 0xff60)
       or (p >= 0xffe0 and p <= 0xffee)
    )
  def getText(self):
    return self.preText.encode('utf8') + self.postText.encode('utf8')
  def updateText(self):
    self.win.erase()
    addstr(self.win, 0, 0, self.getText())
    self.win.noutrefresh()
  def updateCursor(self):
    pos = self.getCursorPos()
    self.win.move(self.line, pos)
    curses.setsyx(self.line, pos)

class SongDisplay():
  def __init__(self, height, width):
    self.height = height
    self.width = width
    self.win = curses.newwin(height-1,width,1,0)
    self.offset = 0
  def setSongs(self, songs):
    self.songs = songs
  def addOffset(self, offset):
    prevOffset = self.offset
    self.offset += offset
    
    limit = len(self.songs) - self.height/3
    limit = 0 if limit < 0 else limit
    if self.offset < 0:
      self.offset = 0
    elif self.offset > limit:
      self.offset = limit

    return self.offset != prevOffset
  def screenFull(self):
    return self.line >= self.height
  def getSongBucket(self, s):
    return s['artist'] + '###' + s['album'] + '###' + s['library']
  def trimMid(self, s, lim, ellip):
    length = len(s)
    if length <= lim:
      return s
    else:
      ellipLen = len(ellip.decode('utf8'))
      left = lim/2
      right = length - lim/2 - lim%2 + ellipLen
      return s[:left] + ellip + s[right:]
  def padNumbers(self, songs):
    maxLen = max([len(s['number']) for s in songs])
    for s in songs:
      numLen = len(s['number'])
      prefix = ('0' if numLen > 0 else ' ') * (maxLen - numLen)
      s['number'] = prefix + s['number']
  def formatSong(self, s):
    return ' ' + s['number'] + ':' + s['title']
  def formatSongBucket(self, s):
    prefix = ''
    sep1 = ' - '
    sep2 = ' ('
    suffix = ')'
    lib = s['library']
    limit = self.width - len(prefix + sep1 + sep2 + lib + suffix)
    artistLimit = limit/2 + limit%2
    albumLimit = limit/2
    artistLen = len(s['artist'])
    albumLen = len(s['album'])
    if artistLimit > artistLen:
      albumLimit += artistLimit - artistLen
      artistLimit = artistLen
    if albumLimit > albumLen:
      artistLimit += albumLimit - albumLen
      albumLimit = albumLen

    ellip = unichr(8230).encode('utf8') #HORIZONTAL ELLIPSIS
    artist = self.trimMid(s['artist'], artistLimit, ellip)
    album = self.trimMid(s['album'], albumLimit, ellip)
    return prefix + artist + sep1 + album + sep2 + lib + suffix
  def getSummary(self, songs):
    songLen = 0
    artists = dict()
    albums = dict()
    libs = dict()

    for s in songs:
      if s['artist'] not in artists:
        artists[s['artist']] = True
      if s['album'] not in albums:
        albums[s['album']] = True
      if s['library'] not in libs:
        libs[s['artist']] = True
      songLen += 1
    return "%d Songs  %d Artists  %d Albums" %(songLen, len(artists), len(albums))
  def getOffsetDisplay(self):
    return '' if self.offset == 0 else " offset=%d" % self.offset
  def printLine(self, msg):
    addstr(self.win, self.line, 0, msg)
    self.line += 1
  def clear(self):
    self.win.erase()
    self.line = 0
  def update(self):
    self.clear()
 
    buckets = dict()
    bucketDisplays = dict()
    bucketOrder = []

    self.addOffset(0)
    count = 0
    limit = self.height - 1
    for song in self.songs[self.offset:self.offset+limit]:
      b = self.getSongBucket(song)
      if b not in buckets:
        buckets[b] = []
        bucketDisplays[b] = self.formatSongBucket(song)
        bucketOrder.append(b)
      buckets[b].append(song)

    self.printLine(self.getSummary(self.songs) + self.getOffsetDisplay())
    for bucket in bucketOrder:
      if self.screenFull():
        break
      self.printLine(bucketDisplays[bucket])
      bucketSongs = buckets[bucket]
      self.padNumbers(bucketSongs)
      for fmtSong in sorted([self.formatSong(s) for s in bucketSongs]):
        self.printLine(fmtSong)
    self.win.noutrefresh()

class KlompQuery():
  def __init__(self):
    self.cols = ['artist', 'album', 'number', 'title', 'relpath', 'library']
    self.query = None
  def buildQueryCmd(self):
    cmd = ["klomp-db", "-s", self.query]
    for col in self.cols:
      cmd.append("--col")
      cmd.append(col)
    return cmd
  def readProc(self, cmdArr):
    out, err = subprocess.Popen(cmdArr, stdout=subprocess.PIPE).communicate()
    return out
  def parseCsv(self, string, colNames):
    return list(csv.DictReader(string.split("\n"), fieldnames=colNames,
      delimiter=',', quotechar='"'))
  def maybePerformQuery(self, query):
    if self.query != query:
      self.query = query
      return self.performQuery()
    else:
      return None
  def performQuery(self):
    return self.parseCsv(self.readProc(self.buildQueryCmd()), self.cols)

class KlompUI():
  def __init__(self):
    self.klompQuery = KlompQuery()
  def start(self, stdscr):
    self.stdscr = stdscr
    height, width = self.stdscr.getmaxyx()
    self.lineEditor = LineEditor(0, width, self.onCommandKey)
    self.songDisplay = SongDisplay(height, width)
    KeyReaderThread(self.stdscr, self.onGetSomeKeys).start()
    while True:
      self.updateSongs()
      time.sleep(1)
  def updateSongs(self):
    songs = self.klompQuery.maybePerformQuery(self.lineEditor.getText())
    if songs != None:
      self.songDisplay.setSongs(songs)
      self.updateSongDisplay()
  def onCommandKey(self, key):
    c = curses
    offsetKeys = {c.KEY_UP: -1, c.KEY_DOWN: 1, c.KEY_PPAGE: -10, c.KEY_NPAGE: 10}

    if key == c.KEY_ENTER:
      pass
    elif key in offsetKeys:
      if self.songDisplay.addOffset(offsetKeys[key]):
        self.updateSongDisplay()
  def onGetSomeKeys(self, keys):
    self.lineEditor.handleKeys(keys)
    self.updateLineEditorDisplay()
  def updateLineEditorDisplay(self):
    with uiLock:
      self.lineEditor.updateText()
      self.lineEditor.updateCursor()
      curses.doupdate()
  def updateSongDisplay(self):
    with uiLock:
      self.songDisplay.update()
      self.lineEditor.updateCursor()
      curses.doupdate()

if __name__ == "__main__":
  main(sys.argv)
