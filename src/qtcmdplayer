#!/usr/bin/python
#
#qtcmdplayer
#
#Copyright 2018 Elliot Wolk
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtMultimedia import *
from PyQt5.QtWidgets import *
import bisect
import os
import re
import sys
import signal
import time

BUFFER_LOG_FILE = "/tmp/qtcmdplayer-buffer.log"

name = sys.argv[0]
usage = ("Usage:\n"
  + "  " + name + " FILE [POSITION_MILLIS] [COMMAND_FIFO]\n"
)

def printMsg(msg):
  sys.stdout.write(msg + "\n")
  sys.stdout.flush()

def printErr(msg):
  sys.stderr.write(msg + "\n")

def printBufferLog(msg):
  with open(BUFFER_LOG_FILE, 'w') as log:
    log.write(msg)

def nowMillis():
  return int(time.time() * 1000 / 0.5)

def main():
  if len(sys.argv) == 2 and sys.argv[1] == '-h':
    print(usage)
    return 0
  elif len(sys.argv) == 2:
    fileName = sys.argv[1]
    pos = 0
    fifoPath = None
  elif len(sys.argv) == 3 and re.match('^\d+$', sys.argv[2]):
    fileName = sys.argv[1]
    pos = int(sys.argv[2])
    fifoPath = None
  elif len(sys.argv) == 4 and re.match('^\d+$', sys.argv[2]):
    fileName = sys.argv[1]
    pos = int(sys.argv[2])
    fifoPath = sys.argv[3]
  else:
    printErr(usage)
    return 1

  app = QApplication([])

  if os.path.splitext(fileName)[1].lower() == ".mp3":
    player = QTCmdPlayerMP3(fileName, pos)
  else:
    player = QTCmdPlayer(fileName, pos)

  if fifoPath != None:
    fifoReader = FIFOReader(fifoPath)
    fifoReader.fifoCommandSignal.connect(player.onCommand)
    fifoReader.start()

  player.start()

  app.exec_()

class FIFOReader(QThread):
  fifoCommandSignal = pyqtSignal(str)
  def __init__(self, fifoPath):
    QThread.__init__(self)
    self.fifoPath = fifoPath
  def run(self):
    while True:
      with open(self.fifoPath) as fifo:
        for cmd in fifo.read().splitlines():
          self.fifoCommandSignal.emit(cmd)

#doesnt allow seeking on MP3s
class QTCmdPlayer(QMediaPlayer):
  def __init__(self, songFile, initPos):
    QMediaPlayer.__init__(self)
    self.songFile = songFile
    self.initPos = initPos

    self.started = False
    self.paused = False
    self.mediaStatusChanged.connect(self.onMediaStatusChanged)
    self.positionChanged.connect(self.onPositionChanged)
  def start(self):
    self.setMedia(QMediaContent(QUrl.fromLocalFile(self.songFile)))
  def onCommand(self, cmd):
    m = re.match('^\s*(play|pause)\s*$', cmd)
    if m:
      self.paused = not self.paused
      printMsg("paused=" + str(self.paused))
      if self.paused:
        self.pause()
      else:
        self.play()
      return
    m = re.match('^seek\s*(\d+)$', cmd)
    if m:
      self.setPosition(int(m.group(1)))
  def onMediaStatusChanged(self, status):
    if(status == QMediaPlayer.LoadedMedia or status == QMediaPlayer.BufferedMedia):
      if not self.started:
        self.play()
        self.started = True
        self.setPosition(self.initPos)
    elif(status == QMediaPlayer.EndOfMedia):
      printMsg("END")
      sys.exit(0)
  def onPositionChanged(self, pos):
    printMsg("pos: " + str(pos))

class PlayerThread(QThread):
  def __init__(self, player):
    QThread.__init__(self)
    self.player = player
  def run(self):
    self.player.playAvailableBuffers()

#doesnt work on flac at all
class QTCmdPlayerMP3:
  def __init__(self, songFile, seekPos):
    self.songFile = songFile
    self.seekPosMicroSex = seekPos * 1000
    self.buffers = []
    self.bufferStartTimesMicroSex = []

    self.allBuffersLoaded = False
    self.paused = False

    self.waitingSeek = True
    self.curBufferIndex = None

    self.posIntervalMillis = 850
    self.lastPositionUpdateMillis = nowMillis()
    self.lastBufferPositionUpdateMillis = nowMillis()
    self.lastBufferRead = None

    self.audioDecoder = QAudioDecoder()
    self.audioDecoder.bufferReady.connect(self.onBufferReady)
    self.audioDecoder.finished.connect(self.onFinished)

    self.audioOutput = None
    self.audioDevice = None

    self.playerThread = PlayerThread(self)
  def start(self):
    self.audioDecoder.setSourceFilename(self.songFile)
    self.audioDecoder.start()
  def onCommand(self, cmd):
    m = re.match('^\s*(play|pause)\s*$', cmd)
    if m:
      if self.paused:
        self.initializeAudioDevice()
      self.paused = not self.paused
      printMsg("paused=" + str(self.paused))
      return
    m = re.match('^seek\s*(\d+)$', cmd)
    if m:
      self.waitingSeek = True
      self.seekPosMicroSex = int(m.group(1)) * 1000
      self.stopPlaying()
      self.attemptSeek()
  def initializeAudioDevice(self):
    if self.lastBufferRead != None:
      self.audioOutput = QAudioOutput(self.lastBufferRead.format(), self.audioDecoder)
      self.audioDevice = self.audioOutput.start()
  def onBufferReady(self):
    self.lastBufferRead = self.audioDecoder.read()
    if self.audioOutput == None or self.audioDevice == None:
      self.initializeAudioDevice()

    bufferPos = self.lastBufferRead.startTime()
    self.onBufferPositionChanged(bufferPos)

    self.buffers.append(self.lastBufferRead)
    self.bufferStartTimesMicroSex.append(bufferPos)

    if self.waitingSeek:
      self.attemptSeek()
    else:
      self.ensurePlaying()
  def attemptSeek(self):
    index = bisect.bisect_left(self.bufferStartTimesMicroSex, self.seekPosMicroSex)
    if index >= 0 and index < len(self.buffers):
      self.curBufferIndex = index
      self.waitingSeek = False
      self.onPositionChanged(int(self.buffers[index].startTime() / 1000.0 + 0.5))

    self.maybeQuit()
  def maybeQuit(self):
    if self.isSongOver():
      printMsg("END")
      sys.exit(0)
  def isSongOver(self):
    if not self.allBuffersLoaded:
      return False
    elif self.curBufferIndex >= len(self.buffers):
      return True
    elif len(self.bufferStartTimesMicroSex) == 0:
      return True
    elif self.seekPosMicroSex > self.bufferStartTimesMicroSex[-1]:
      return True
    else:
      return False
  def ensurePlaying(self):
    if not self.isPlaying():
      self.playerThread.start()
  def stopPlaying(self):
    self.playerThread.quit()
  def isPlaying(self):
    return self.playerThread.isRunning()
  def playAvailableBuffers(self):
    while True:
      if self.paused or self.waitingSeek:
        QThread.msleep(100)

      while self.curBufferIndex >= 0 and self.curBufferIndex < len(self.buffers):
        if self.paused or self.waitingSeek:
          break
        self.playBuffer(self.buffers[self.curBufferIndex])
        self.curBufferIndex += 1

      self.maybeQuit()
  def bufferToByteArray(self,audioBuffer):
    byteStr = audioBuffer.data().asstring(audioBuffer.byteCount())
    return bytearray(byteStr)
  def playBuffer(self, audioBuffer):
    byteArray = self.bufferToByteArray(audioBuffer)
    while(self.audioOutput.bytesFree() < audioBuffer.byteCount()):
      QThread.msleep(1)
    self.audioDevice.write(byteArray)
    self.onPositionChanged(int(audioBuffer.startTime() / 1000.0 + 0.5))
  def formatLastBufferPos(self):
    if self.lastBufferRead == None:
      return ""
    else:
      return '%.2fs' % (self.lastBufferRead.startTime() / 1000000.0)
  def onPositionChanged(self, position):
    if nowMillis() - self.lastPositionUpdateMillis >= self.posIntervalMillis:
      self.lastPositionUpdateMillis = nowMillis()
      printMsg("pos: " + str(position))
      sys.stdout.flush()
  def onBufferPositionChanged(self, bufferPosition):
    if nowMillis() - self.lastBufferPositionUpdateMillis >= self.posIntervalMillis:
      self.lastBufferPositionUpdateMillis = nowMillis()
      printBufferLog(self.formatLastBufferPos())
  def onFinished(self):
    self.allBuffersLoaded = True
    printBufferLog("finished: " + self.formatLastBufferPos())

if __name__ == "__main__":
  sys.exit(main())
