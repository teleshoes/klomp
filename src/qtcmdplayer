#!/usr/bin/python
#
#qtcmdplayer
#
#Copyright 2018 Elliot Wolk
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtMultimedia import *
from PyQt5.QtWidgets import *
import os
import re
import sys
import signal
import time

name = sys.argv[0]
usage = ("Usage:\n"
  + "  " + name + " FILE [POSITION_MILLIS] [COMMAND_FIFO]\n"
)

def printErr(msg):
  sys.stderr.write(msg + "\n")

def main():
  if len(sys.argv) == 2 and sys.argv[1] == '-h':
    print(usage)
    return 0
  elif len(sys.argv) == 2:
    fileName = sys.argv[1]
    pos = 0
    fifoPath = None
  elif len(sys.argv) == 3 and re.match('^\d+$', sys.argv[2]):
    fileName = sys.argv[1]
    pos = int(sys.argv[2])
    fifoPath = None
  elif len(sys.argv) == 4 and re.match('^\d+$', sys.argv[2]):
    fileName = sys.argv[1]
    pos = int(sys.argv[2])
    fifoPath = sys.argv[3]
  else:
    printErr(usage)
    return 1

  app = QApplication([])

  if os.path.splitext(fileName)[1].lower() == ".mp3":
    player = QTCmdPlayerMP3(fileName, pos)
  else:
    player = QTCmdPlayer(fileName, pos)

  if fifoPath != None:
    fifoReader = FIFOReader(fifoPath)
    fifoReader.fifoCommandSignal.connect(player.onCommand)
    fifoReader.start()

  player.start()

  app.exec_()

class FIFOReader(QThread):
  fifoCommandSignal = pyqtSignal(str)
  def __init__(self, fifoPath):
    QThread.__init__(self)
    self.fifoPath = fifoPath
  def run(self):
    while True:
      with open(self.fifoPath) as fifo:
        for cmd in fifo.read().splitlines():
          self.fifoCommandSignal.emit(cmd)

#doesnt allow seeking on MP3s
class QTCmdPlayer(QMediaPlayer):
  def __init__(self, songFile, initPos):
    QMediaPlayer.__init__(self)
    self.songFile = songFile
    self.initPos = initPos

    self.started = False
    self.paused = False
    self.mediaStatusChanged.connect(self.onMediaStatusChanged)
    self.positionChanged.connect(self.onPositionChanged)
  def start(self):
    self.setMedia(QMediaContent(QUrl.fromLocalFile(self.songFile)))
  def onCommand(self, cmd):
    m = re.match('^\s*(play|pause)\s*$', cmd)
    if m:
      self.paused = not self.paused
      print "paused=" + str(self.paused)
      if self.paused:
        self.pause()
      else:
        self.play()
      return
    m = re.match('^seek\s*(\d+)$', cmd)
    if m:
      self.setPosition(int(m.group(1)))
  def onMediaStatusChanged(self, status):
    if(status == QMediaPlayer.LoadedMedia or status == QMediaPlayer.BufferedMedia):
      if not self.started:
        self.play()
        self.started = True
        self.setPosition(self.initPos)
    elif(status == QMediaPlayer.EndOfMedia):
      print("END")
      sys.exit(0)
  def onPositionChanged(self, pos):
    print("pos: " + str(pos))
    sys.stdout.flush()

#doesnt work on flac at all
class QTCmdPlayerMP3:
  def __init__(self, songFile, initPos):
    self.songFile = songFile
    self.initPos = initPos

    self.lastInterestingPosition = self.initPos
    self.posInterval = 850

    self.audioDecoder = QAudioDecoder()
    self.audioDecoder.bufferReady.connect(self.onBufferReady)
    self.audioDecoder.finished.connect(self.onFinished)
    self.audioDecoder.positionChanged.connect(self.onPositionChanged)

    self.audioOutput = None
    self.audioDevice = None
  def start(self):
    self.audioDecoder.setSourceFilename(self.songFile)
    self.audioDecoder.start()
  def onCommand(self, cmd):
    pass
  def onBufferReady(self):
    b = self.audioDecoder.read()
    if self.audioOutput == None or self.audioDevice == None:
      self.audioOutput = QAudioOutput(b.format(), self.audioDecoder)
      self.audioDevice = self.audioOutput.start()

    pos = self.audioDecoder.position()
    if pos >= self.initPos:
      self.playBuffer(b)
  def playBuffer(self, audioBuffer):
    byteStr = audioBuffer.data().asstring(audioBuffer.byteCount())
    byteArr = QByteArray.fromRawData(byteStr)
    while(self.audioOutput.bytesFree() < audioBuffer.byteCount()):
      time.sleep(0.001)
    self.audioDevice.write(byteArr)
  def onPositionChanged(self, position):
    if position >= self.lastInterestingPosition + self.posInterval:
      self.lastInterestingPosition = position
      print "pos: " + str(position)
      sys.stdout.flush()
  def onFinished(self):
    print("END")
    sys.exit(0)


if __name__ == "__main__":
  sys.exit(main())
