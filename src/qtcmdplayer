#!/usr/bin/python
#
#qtcmdplayer
#
#Copyright 2018 Elliot Wolk
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtMultimedia import *
from PyQt5.QtWidgets import *
import bisect
import io
import os
import re
import sys
import signal
import time

BUFFER_LOG_FILE = "/tmp/qtcmdplayer-buffer.log"
CACHE_DIR = os.path.expanduser("~/.cache/qtcmdplayer")
BUFFER_CACHE_BYTES_FILE = CACHE_DIR + "/buffer-bytes.cache"
BUFFER_CACHE_INFO_FILE = CACHE_DIR + "/buffer-info.cache"
BUFFER_CACHE_AUDIOFORMAT_FILE = CACHE_DIR + "/buffer-audioformat.cache"
BUFFER_CACHE_LAST_SONG_INFO_FILE = CACHE_DIR + "/buffer-lastsonginfo.cache"

name = sys.argv[0]
usage = ("Usage:\n"
  + "  " + name + " FILE [POSITION_MILLIS] [COMMAND_FIFO]\n"
)

def printMsg(msg):
  sys.stdout.write(msg + "\n")
  sys.stdout.flush()

def printErr(msg):
  sys.stderr.write(msg + "\n")

def printBufferLog(msg):
  with open(BUFFER_LOG_FILE, 'w') as log:
    log.write(msg)

def nowMillis():
  return int(time.time() * 1000 / 0.5)
def sleepUntil(intervalMillis, timeoutMillis, cond):
  startMillis = nowMillis()
  while not cond() and nowMillis() - startMillis < timeoutMillis:
    QThread.msleep(intervalMillis)

def rmFile(f):
  if os.path.isfile(f):
    os.remove(f)

def main():
  if len(sys.argv) == 2 and sys.argv[1] == '-h':
    print(usage)
    return 0
  elif len(sys.argv) == 2:
    fileName = sys.argv[1]
    pos = 0
    fifoPath = None
  elif len(sys.argv) == 3 and re.match('^\d+$', sys.argv[2]):
    fileName = sys.argv[1]
    pos = int(sys.argv[2])
    fifoPath = None
  elif len(sys.argv) == 4 and re.match('^\d+$', sys.argv[2]):
    fileName = sys.argv[1]
    pos = int(sys.argv[2])
    fifoPath = sys.argv[3]
  else:
    printErr(usage)
    return 1

  app = QApplication([])

  if os.path.splitext(fileName)[1].lower() == ".mp3":
    player = QTCmdPlayerMP3(fileName, pos)
  else:
    player = QTCmdPlayer(fileName, pos)

  if fifoPath != None:
    fifoReader = FIFOReader(fifoPath)
    fifoReader.fifoCommandSignal.connect(player.onCommand)
    fifoReader.start()

  player.start()

  app.exec_()

class FIFOReader(QThread):
  fifoCommandSignal = pyqtSignal(str)
  def __init__(self, fifoPath):
    QThread.__init__(self)
    self.fifoPath = fifoPath
  def run(self):
    while True:
      with open(self.fifoPath) as fifo:
        for cmd in fifo.read().splitlines():
          self.fifoCommandSignal.emit(cmd)

#doesnt allow seeking on MP3s
class QTCmdPlayer(QMediaPlayer):
  def __init__(self, songFile, initPos):
    QMediaPlayer.__init__(self)
    self.songFile = songFile
    self.initPos = initPos

    self.started = False
    self.paused = False
    self.mediaStatusChanged.connect(self.onMediaStatusChanged)
    self.positionChanged.connect(self.onPositionChanged)
  def start(self):
    self.setMedia(QMediaContent(QUrl.fromLocalFile(self.songFile)))
  def onCommand(self, cmd):
    m = re.match('^\s*(play|pause)\s*$', cmd)
    if m:
      self.paused = not self.paused
      printMsg("paused=" + str(self.paused))
      if self.paused:
        self.pause()
      else:
        self.play()
      return
    m = re.match('^seek\s*(\d+)$', cmd)
    if m:
      self.setPosition(int(m.group(1)))
  def onMediaStatusChanged(self, status):
    if(status == QMediaPlayer.LoadedMedia or status == QMediaPlayer.BufferedMedia):
      if not self.started:
        self.play()
        self.started = True
        self.setPosition(self.initPos)
    elif(status == QMediaPlayer.EndOfMedia):
      printMsg("END")
      sys.exit(0)
  def onPositionChanged(self, pos):
    printMsg("pos: " + str(pos))

class PlayerThread(QThread):
  def __init__(self, player):
    QThread.__init__(self)
    self.player = player
  def run(self):
    self.player.playAvailableBuffers()

#doesnt work on flac at all
class QTCmdPlayerMP3(QObject):
  initAudioDeviceSignal = pyqtSignal()
  def __init__(self, songFile, seekPos):
    QObject.__init__(self)
    self.songFile = songFile
    self.seekPosMicroSex = seekPos * 1000

    self.bufferStartTimes = []
    self.bufferByteOffsets = []
    self.bufferByteSizes = []
    self.nextByteOffset = 0

    self.allBuffersLoaded = False
    self.paused = False

    self.waitingSeek = True
    self.curBufferIndex = None

    self.posIntervalMillis = 850
    self.lastPositionUpdateMillis = nowMillis()
    self.lastBufferPositionUpdateMillis = nowMillis()
    self.audioFormat = None
    self.lastBufferReadStartTime = None

    self.audioDecoder = QAudioDecoder()
    self.audioDecoder.bufferReady.connect(self.onBufferReady)
    self.audioDecoder.finished.connect(self.onFinished)

    self.audioOutput = None
    self.audioDevice = None

    self.playerThread = PlayerThread(self)
    self.initAudioDeviceSignal.connect(self.initAudioDevice)

  def start(self):
    if FileCache(self.songFile, BUFFER_CACHE_LAST_SONG_INFO_FILE).compareCache():
      self.startFromCache()
    else:
      self.startFromDecoder()
  def startFromDecoder(self):
    if not os.path.isdir(CACHE_DIR):
      os.makedirs(CACHE_DIR)
    rmFile(BUFFER_CACHE_BYTES_FILE)
    rmFile(BUFFER_CACHE_INFO_FILE)
    rmFile(BUFFER_CACHE_AUDIOFORMAT_FILE)
    rmFile(BUFFER_CACHE_LAST_SONG_INFO_FILE)
    self.bufferCacheWriteFH = open(BUFFER_CACHE_BYTES_FILE, 'w')
    self.bufferCacheReadFH = open(BUFFER_CACHE_BYTES_FILE, 'r')

    self.audioDecoder.setSourceFilename(self.songFile)
    self.audioDecoder.start()
  def startFromCache(self):
    self.readBufferInfoCache()
    self.readAudioFormatCache()
    self.ensurePlaying()

    self.audioDecoder = None
    self.bufferCacheWriteFH = None
    self.bufferCacheReadFH = open(BUFFER_CACHE_BYTES_FILE, 'r')

    self.refreshAudioDevice()

    if self.waitingSeek:
      self.attemptSeek()
    else:
      self.ensurePlaying()
  def readBufferInfoCache(self):
    lines = None
    with open(BUFFER_CACHE_INFO_FILE, 'r') as f:
      lines = f.readlines()

    self.bufferStartTimes = []
    self.bufferByteOffsets = []
    self.bufferByteSizes = []
    self.nextByteOffset = 0
    for line in lines:
      m = re.match("^(\\d+) (\\d+)$", line)
      if m:
        startTime = int(m.group(1))
        byteSize = int(m.group(2))
        self.bufferStartTimes.append(startTime)
        self.bufferByteOffsets.append(self.nextByteOffset)
        self.bufferByteSizes.append(byteSize)
        self.nextByteOffset += byteSize
        self.lastBufferReadStartTime = startTime
      else:
        printErr("malformed buffer-info cache line: " + str(line))
        sys.exit(1)
    self.allBuffersLoaded = True
  def writeBufferInfoCache(self):
    with open(BUFFER_CACHE_INFO_FILE, 'w') as f:
      i = 0
      while i < len(self.bufferStartTimes):
        startTime = self.bufferStartTimes[i]
        byteSize = self.bufferByteSizes[i]
        f.write(str(startTime) + " " + str(byteSize) + "\n")
        i += 1
  def readAudioFormatCache(self):
    lines = None
    with open(BUFFER_CACHE_AUDIOFORMAT_FILE, 'r') as f:
      lines = f.readlines()

    self.audioFormat = QAudioFormat()
    for line in lines:
      intMatch = re.match("^(\\w+)\\s*=\\s*(\\d+)$", line)
      strMatch = re.match("^(\\w+)\\s*=\\s*(.+)$", line)
      if intMatch:
        key = intMatch.group(1)
        val = int(intMatch.group(2))
        if key == "sampleRate":
          self.audioFormat.setSampleRate(val)
        elif key == "sampleSize":
          self.audioFormat.setSampleSize(val)
        elif key == "sampleType":
          self.audioFormat.setSampleType(val)
        elif key == "channelCount":
          self.audioFormat.setChannelCount(val)
        elif key == "byteOrder":
          self.audioFormat.setByteOrder(val)
        else:
          printErr("unknown audio format key: " + str(key))
          sys.exit(1)
      elif strMatch:
        key = strMatch.group(1)
        val = strMatch.group(2)
        if key == "codec":
          self.audioFormat.setCodec(val)
        else:
          printErr("unknown audio format key: " + str(key))
          sys.exit(1)
      else:
        printErr("malformed audio format cache line: " + str(line))
        sys.exit(1)
  def writeAudioFormatCache(self):
    with open(BUFFER_CACHE_AUDIOFORMAT_FILE, 'w') as f:
      f.write("codec=" + str(self.audioFormat.codec()) + "\n")
      f.write("sampleRate=" + str(self.audioFormat.sampleRate()) + "\n")
      f.write("sampleSize=" + str(self.audioFormat.sampleSize()) + "\n")
      f.write("sampleType=" + str(self.audioFormat.sampleType()) + "\n")
      f.write("channelCount=" + str(self.audioFormat.channelCount()) + "\n")
      f.write("byteOrder=" + str(self.audioFormat.byteOrder()) + "\n")
  def bufferCount(self):
    return len(self.bufferStartTimes)
  def readBufferByteArr(self, index):
    byteSize = self.bufferByteSizes[index]
    byteOffset = self.bufferByteOffsets[index]
    self.bufferCacheReadFH.seek(byteOffset, io.SEEK_SET)
    return bytearray(self.bufferCacheReadFH.read(byteSize))
  def readBufferStartTime(self, index):
    return self.bufferStartTimes[index]
  def appendBuffer(self, byteArr, startTime):
    self.bufferCacheWriteFH.seek(0, io.SEEK_END)
    self.bufferCacheWriteFH.write(byteArr)

    byteSize = len(byteArr)
    byteOffset = self.nextByteOffset
    self.nextByteOffset += byteSize

    self.bufferStartTimes.append(startTime)
    self.bufferByteSizes.append(byteSize)
    self.bufferByteOffsets.append(byteOffset)

    self.onBufferPositionChanged(startTime)
  def onCommand(self, cmd):
    m = re.match('^\s*(play|pause)\s*$', cmd)
    if m:
      if self.paused:
        self.refreshAudioDevice()
      self.paused = not self.paused
      printMsg("paused=" + str(self.paused))
      return
    m = re.match('^seek\s*(\d+)$', cmd)
    if m:
      self.waitingSeek = True
      self.seekPosMicroSex = int(m.group(1)) * 1000
      self.stopPlaying()
      self.attemptSeek()
  def refreshAudioDevice(self):
    if self.audioFormat != None:
      self.audioOutput = None
      self.audioDevice = None
      self.initAudioDeviceSignal.emit()
      sleepUntil(1, 1000, lambda: self.audioDevice != None)
  def initAudioDevice(self):
    if self.audioFormat != None:
      self.audioOutput = QAudioOutput(self.audioFormat, self)
      self.audioDevice = self.audioOutput.start()
  def onBufferReady(self):
    buf = self.audioDecoder.read()
    startTime = buf.startTime()
    byteArr = self.bufferToByteArray(buf)

    if self.audioFormat == None:
      self.audioFormat = buf.format()

    self.lastBufferReadStartTime = startTime

    self.appendBuffer(byteArr, startTime)

    if self.audioOutput == None or self.audioDevice == None:
      self.refreshAudioDevice()

    if self.waitingSeek:
      self.attemptSeek()
    else:
      self.ensurePlaying()
  def attemptSeek(self):
    index = bisect.bisect_left(self.bufferStartTimes, self.seekPosMicroSex)
    if index >= 0 and index < self.bufferCount():
      self.curBufferIndex = index
      self.waitingSeek = False
      bufferPos = self.readBufferStartTime(index)
      self.onPositionChanged(int(bufferPos / 1000.0 + 0.5))

    self.maybeQuit()
  def maybeQuit(self):
    if self.isSongOver():
      printMsg("END")
      sys.exit(0)
  def isSongOver(self):
    if not self.allBuffersLoaded:
      return False
    elif self.curBufferIndex >= self.bufferCount():
      return True
    elif self.bufferCount() == 0:
      return True
    elif self.seekPosMicroSex > self.lastBufferReadStartTime:
      return True
    else:
      return False
  def ensurePlaying(self):
    if not self.isPlaying():
      self.playerThread.start()
  def stopPlaying(self):
    self.playerThread.quit()
  def isPlaying(self):
    return self.playerThread.isRunning()
  def isReadyToPlay(self):
    return not self.paused and not self.waitingSeek and self.isBufferAvailable()
  def isBufferAvailable(self):
    return self.curBufferIndex >= 0 and self.curBufferIndex < self.bufferCount()
  def playAvailableBuffers(self):
    while True:
      sleepUntil(100, 1000, self.isReadyToPlay)

      while self.isReadyToPlay():
        bufferPos = self.readBufferStartTime(self.curBufferIndex)
        byteArray = self.readBufferByteArr(self.curBufferIndex)
        self.playBuffer(byteArray, bufferPos)
        self.curBufferIndex += 1

      self.maybeQuit()
  def bufferToByteArray(self, audioBuffer):
    byteStr = audioBuffer.data().asstring(audioBuffer.byteCount())
    return bytearray(byteStr)
  def playBuffer(self, audioBufferByteArr, bufferPos):
    bufferSize = len(audioBufferByteArr)

    sleepUntil(1, 1000, lambda: self.audioOutput.bytesFree() >= bufferSize)

    if self.audioOutput.bytesFree() < bufferSize:
      printErr("WAITING OVER A SECOND FOR AUDIO DEVICE, RE-INTIIALIZING")
      self.refreshAudioDevice()
      sleepUntil(1, 1000, lambda: self.audioOutput.bytesFree() >= bufferSize)

    self.audioDevice.write(audioBufferByteArr)
    self.onPositionChanged(int(bufferPos / 1000.0 + 0.5))
  def formatLastBufferPos(self):
    if self.lastBufferReadStartTime == None:
      return ""
    else:
      return '%.2fs' % (self.lastBufferReadStartTime / 1000000.0)
  def onPositionChanged(self, position):
    if nowMillis() - self.lastPositionUpdateMillis >= self.posIntervalMillis:
      self.lastPositionUpdateMillis = nowMillis()
      printMsg("pos: " + str(position))
      sys.stdout.flush()
  def onBufferPositionChanged(self, bufferPosition):
    if nowMillis() - self.lastBufferPositionUpdateMillis >= self.posIntervalMillis:
      self.lastBufferPositionUpdateMillis = nowMillis()
      printBufferLog(self.formatLastBufferPos())
  def onFinished(self):
    self.allBuffersLoaded = True
    printBufferLog("finished: " + self.formatLastBufferPos())

    self.writeBufferInfoCache()
    self.writeAudioFormatCache()

    FileCache(self.songFile, BUFFER_CACHE_LAST_SONG_INFO_FILE).writeInfoCache()

class FileCache:
  def __init__(self, srcFile, infoCacheFile):
    self.srcFile = srcFile
    self.infoCacheFile = infoCacheFile
  def getSrcFileMtime(self):
    return int(os.path.getmtime(self.srcFile))
  def getSrcFileSize(self):
    return int(os.path.getsize(self.srcFile))
  def readInfoCache(self):
    try:
      with open(self.infoCacheFile, 'r') as f:
        s = f.read()
        m = re.match("^(\\d+) (\\d+) (.+)$", s)
        if m:
          return { "mtime": int(m.group(1))
                 , "size": int(m.group(2))
                 , "path": m.group(3)
                 }
        else:
          return None
    except:
      return None
  def writeInfoCache(self):
    with open(self.infoCacheFile, 'w') as f:
      f.write("%d %d %s" % (self.getSrcFileMtime(), self.getSrcFileSize(), self.srcFile))
  def compareCache(self):
    info = self.readInfoCache()
    return (
      info != None
      and info["path"] == self.srcFile
      and info["mtime"] == self.getSrcFileMtime()
      and info["size"] == self.getSrcFileSize()
    )

if __name__ == "__main__":
  sys.exit(main())
