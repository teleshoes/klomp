#!/usr/bin/perl
use strict;
use warnings;
use lib "/opt/klomp/lib";
use Klomp::Files;

my $KLOMP_CUR = Klomp::Files::klompFile("cur");
my $KLOMP_HIST = Klomp::Files::klompFile("hist");

my @attColNames = qw(title artist album number);
my @colNames = (@attColNames, "pos", "len", "percent", "playlist", "ended");
my $validAttColNames = join "|", @attColNames;
my $validColNames = join "|", @colNames;

my $usage = "Usage:
  $0 [OPTS] [COL COL COL ..]
    print values for COLs, separated by spaces
    values are read from $KLOMP_CUR, or if its missing,
    from the first line of $KLOMP_HIST
    if no COLs are given, all are used
      i.e.: \"@colNames\"

  COL:
    [$validColNames]
      playlist: \"|PLAYLIST_NAME|\" unless playlist is main
      ended:    \"|ended|\" if klomp cur file is missing
      pos:      current position in M:SS or H:MM:SS {or S.ss if -s}
      len:      length in M:SS or H:MM:SS {or S.ss if -s}
      percent:  integer between 0 and 100 for pos/len

  OPTS:
    -n  do not output a trailing newline
    -c  output as CSV
    -h  output a csv header showing the column names first
    -s  output times in fractional seconds instead of M:SS or H:MM:SS
";

sub getCur();
sub formatHMS($);

sub main(@){
  my $newline = 1;
  my $csv = 0;
  my $header = 0;
  my $seconds = 0;
  while(@_ > 0 and $_[0] =~ /^(-n|-c|-h|-s)$/){
    my $arg = shift;
    $newline = 0 if $arg eq '-n';
    $csv = 1 if $arg eq '-c';
    $header = 1 if $arg eq '-h';
    $seconds = 1 if $arg eq '-s';
  }

  my @cols = @_;
  @cols = @colNames if @cols == 0;

  my $cur = getCur();
  my @info;
  for my $col(@cols){
    if($col eq 'playlist'){
      my $pl = `klomp-cmd playlist`;
      chomp $pl;
      my $playlist = $pl eq 'main' ? "" : "|$pl|";
      push @info, $playlist;
    }elsif($col eq 'ended'){
      my $ended = -e $KLOMP_CUR ? "" : "|ended|";
      push @info, $ended;
    }elsif($col =~ /^(pos|len|percent)$/){
      my ($pos, $len, $percent) = (0, 0, 0);
      if($cur =~ /^(\d+\.\d+)\s*(\d+\.\d+)/){
        ($pos, $len) = ($1, $2);
        $percent = $len > 0 ? $pos/$len*100 : 0;
      }
      $percent = sprintf "%.0f", $percent;
      push @info, ($seconds ? $pos : formatHMS $pos) if $col eq 'pos';
      push @info, ($seconds ? $len : formatHMS $len) if $col eq 'len';
      push @info, "|$percent|" if $col eq 'percent';
    }elsif($col =~ /^($validAttColNames)$/){
      my $att = $cur =~ /^$col=(.*)$/m ? $1 : "";
      push @info, $att;
    }else{
      die $usage;
    }
  }
  print join(",", @cols) . "\n" if $header;
  if($csv){
    my @csvInfo;
    for my $s(@info){
      if($s =~ /[",\r\n]/){
        $s =~ s/"/""/g;
        $s = "\"$s\"";
      }
      push @csvInfo, $s;
    }
    print join ',', @csvInfo;
  }else{
    print join " ", grep {defined $_ and length $_ > 0} @info;
  }
  print "\n" if $newline;
}

sub getCur(){
  if(-e $KLOMP_CUR){
    return `cat $KLOMP_CUR`;
  }elsif(-e $KLOMP_HIST){
    my $cur = `head -1 $KLOMP_HIST`;
    $cur =~ s/\/\/\/\\\\\\/\n/g;
    return $cur;
  }else{
    return "";
  }
}

sub formatHMS($){
  my $time = shift;
  $time = int(0.5 + $time);
  my $h = int($time / (60*60));
  my $m = int($time % (60*60) / (60));
  my $s = $time - ($m*60) - ($h*60*60);
  $s = "0$s" if $s < 10;

  if($h == 0){
    return "$m:$s";
  }else{
    $m = "0$m" if $m < 10;
    return "$h:$m:$s";
  }
}

&main(@ARGV);
