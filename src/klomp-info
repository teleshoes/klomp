#!/usr/bin/perl
use strict;
use warnings;
use lib "/opt/klomp/lib";
use Klomp::Files;

my $KLOMP_CUR = Klomp::Files::klompFile("cur");
my $KLOMP_HIST = Klomp::Files::klompFile("hist");
my $KLOMP_LIST = Klomp::Files::klompFile("list");

my @attColNames = qw(title artist album number);
my @calcColNames = qw(pos len percent playlist ended breaks);

my @allColNames = (@attColNames, @calcColNames);
my @defaultColNames = (@attColNames, @calcColNames);
my $validAttColNames = join "|", @attColNames;
my $validColNames = join "|", @allColNames;

my $breakLine = "!klomp-cmd stop";

my $usage = "Usage:
  $0 [OPTS] [COL COL COL ..] [INDEX INDEX INDEX ..]
    print values for COLs, separated by spaces
    if no COL is given, all are used
      i.e.: \"@defaultColNames\"
    each INDEX is printed one per line. values are read from:
      $KLOMP_CUR {INDEX=0}
      $KLOMP_HIST {INDEX<0}
      $KLOMP_LIST {INDEX>0}
    if no INDEX is given, \"0\" is used

  COL:
    [$validColNames]
      playlist: \"PLAYLIST_NAME\" unless playlist is main
      ended:    \"ended\" if klomp cur file is missing
      pos:      current position in M:SS or H:MM:SS {or S.ss if -s}
      len:      length in M:SS or H:MM:SS {or S.ss if -s}
      percent:  integer between 0 and 100 for pos/len
      breaks:   \"{BR}\" if playlist contains the line \"$breakLine\"

      non-empty values for playlist, ended, and percent
      are wrapped in |s unless CSV output is on
      e.g.: \"|ended|\"

  INDEX:
      0     current song in klompcur
      +N    line number in playlist {+1 is the next song to be played}
      -N    line number in history {-1 is the song that finished most recently}
      [X,Y] use all indices between X and Y  {X<=Y}

      song information is printed, one per line, for each indicated index.
      COL \"pos\" is 0 for every song except index \"0\"

      if any index is specified, each line is prefixed by \"INDEX:\"

      if an index does not exist, the closest index to it is used.
      if two indices are the same distance away, the lower of the two is used.
      {e.g.:   if index 0 is specified and there is no current song,
               the last played song is used, and if that doesnt exist,
               the next song in the playlist is used}

  OPTS:
    -n  do not output a trailing newline
    -c  output as CSV
    -h  output a csv header showing the column names first
    -s  output times in fractional seconds instead of M:SS or H:MM:SS
    --format=FORMAT
      runs `printf FORMAT VAL VAL ...` where VAL is the value of each COL given
      cannot give -c and --format
      e.g.:  > $0 --format=\"%s / %s\\n%s\" pos len title
             0:26 / 10:13
             Rinse The Raindrops
";

sub parseInfo($$$$$$);
sub readKlompInfo($$);
sub selectKlompInfo($$$$);
sub formatHMS($);
sub formatSep($$);
sub parseIndices($);

sub main(@){
  my $newline = 1;
  my $csv = 0;
  my $header = 0;
  my $seconds = 0;
  my $format;
  while(@_ > 0 and $_[0] =~ /^(-n|-c|-h|-s|--format=.*)$/){
    my $arg = shift;
    $newline = 0 if $arg eq '-n';
    $csv = 1 if $arg eq '-c';
    $header = 1 if $arg eq '-h';
    $seconds = 1 if $arg eq '-s';
    $format = $1 if $arg =~ /^--format=(.*)$/;
  }
  die $usage if $csv and defined $format;

  my @cols;
  while(@_ > 0 and $_[0] =~ /^($validColNames)$/){
    push @cols, shift;
  }
  @cols = @defaultColNames if @cols == 0;

  my @indices;
  while(@_ > 0){
    my $newIndices = parseIndices shift;
    die $usage if not defined $newIndices;
    @indices = (@indices, @$newIndices);
  }
  @indices = (0) if @indices == 0;
  my $max = 0;
  my $min = 0;
  for my $index(@indices){
    $max = $index if $index > $max;
    $min = $index if $index < $min;
  }
  $max = 0 if $max<0;

  die $usage if @_ != 0;

  print join(",", @cols) . "\n" if $header;

  my ($curInfo, $histInfo, $listInfo) = readKlompInfo $min, $max;

  my $playlist = grep(/playlist/, @cols) ? `klomp-cmd playlist` : "";
  chomp $playlist;

  my $first = 1;
  for my $index(@indices){
    my $klompInfo = selectKlompInfo $index, $curInfo, $histInfo, $listInfo;
    if(not defined $klompInfo){
      print STDERR "No song info found\n";
      $klompInfo = "";
    }
    my $info = parseInfo $klompInfo, $playlist, \@cols, $csv, $seconds, $format;
    print "\n" unless $first;
    $first = 0;
    print $info;
  }
  print "\n" if $newline;
}

sub parseInfo($$$$$$){
  my ($klompInfo, $playlist, $cols, $csv, $seconds, $format) = @_;
  my @info;
  for my $col(@$cols){
    if($col eq 'playlist'){
      my $pl = $playlist eq 'main' ? "" : formatSep $playlist, $csv;
      push @info, $pl;
    }elsif($col eq 'ended'){
      my $ended = -e $KLOMP_CUR ? "" : formatSep "ended", $csv;
      push @info, $ended;
    }elsif($col =~ /^(pos|len|percent)$/){
      my ($pos, $len, $percent) = (0, 0, 0);
      if($klompInfo =~ /^(\d+\.\d+)\s*(\d+\.\d+)/){
        ($pos, $len) = ($1, $2);
      }
      if($len == 0 and $klompInfo =~ /^duration=(\d+\.\d+)$/m){
        $len = $1;
      }
      $percent = $len > 0 ? $pos/$len*100 : 0;
      $percent = sprintf "%.0f", $percent;
      push @info, ($seconds ? $pos : formatHMS $pos) if $col eq 'pos';
      push @info, ($seconds ? $len : formatHMS $len) if $col eq 'len';
      push @info, formatSep "$percent", $csv if $col eq 'percent';
    }elsif($col eq 'breaks'){
      my $count = `grep "$breakLine" "$KLOMP_LIST" | wc -l`;
      push @info, $count > 0 ? "{BR}" : "";
    }elsif($col =~ /^($validAttColNames)$/){
      my $att = $klompInfo =~ /^$col=(.*)$/m ? $1 : "";
      push @info, $att;
    }else{
      die $usage;
    }
  }

  if($csv){
    my @csvInfo;
    for my $s(@info){
      if($s =~ /[",\r\n]/){
        $s =~ s/"/""/g;
        $s = "\"$s\"";
      }
      push @csvInfo, $s;
    }
    return join ',', @csvInfo;
  }elsif(defined $format){
    open FH, "-|", "printf", $format, @info;
    my @lines = <FH>;
    close FH;
    return join '', @lines;
  }else{
    return join " ", grep {defined $_ and length $_ > 0} @info;
  }
}

sub readKlompInfo($$){
  my ($min, $max) = @_;

  my $curInfo = undef;
  my $histInfo = [];
  my $listInfo = [];

  $curInfo = `cat $KLOMP_CUR` if -e $KLOMP_CUR;
  if((not defined $curInfo or $min < 0) and -e $KLOMP_HIST){
    $min = 0-$min;
    $min = 1 if $min == 0;
    for my $line(`head -$min $KLOMP_HIST`){
      $line =~ s/\/\/\/\\\\\\/\n/g;
      push @$histInfo, $line;
    }
  }
  if((not defined $curInfo or $max > 0) and -e $KLOMP_LIST){
    $max = 1 if $max == 0;
    for my $line(`head -$max $KLOMP_LIST`){
      $line =~ s/\/\/\/\\\\\\/\n/g;
      push @$listInfo, $line;
    }
  }

  return ($curInfo, $histInfo, $listInfo);
}

sub selectKlompInfo($$$$){
  my ($index, $curInfo, $histInfo, $listInfo) = @_;
  if($index == 0){
    return $curInfo if defined $curInfo;
    return $$histInfo[0] if @$histInfo > 0;
    return $$listInfo[0] if @$listInfo > 0;
  }elsif($index > 0){
    $index = @$listInfo - 1 if $index >= @$listInfo;
    return $$listInfo[$index] if @$listInfo > 0;
    return $curInfo if defined $curInfo;
    return $$histInfo[0] if @$histInfo > 0;
  }elsif($index < 0){
    $index = 0 - $index;
    $index = @$histInfo - 1 if $index >= @$histInfo;
    return $$histInfo[$index] if @$histInfo > 0;
    return $curInfo if defined $curInfo;
    return $$listInfo[0] if @$listInfo > 0;
  }
  return undef;
}

sub formatHMS($){
  my $time = shift;
  $time = int(0.5 + $time);
  my $h = int($time / (60*60));
  my $m = int($time % (60*60) / (60));
  my $s = $time - ($m*60) - ($h*60*60);
  $s = "0$s" if $s < 10;

  if($h == 0){
    return "$m:$s";
  }else{
    $m = "0$m" if $m < 10;
    return "$h:$m:$s";
  }
}

sub formatSep($$){
  my ($s, $csv) = @_;
  return $csv ? $s : "|$s|";
}

sub parseIndices($){
  my $index = shift;
  if($index eq "0"){
    return [0];
  }elsif($index =~ /^\+(\d+)$/){
    my $val = 0 + $1;
    return [$val] if $val > 0;
  }elsif($index =~ /^\-(\d+)$/){
    my $val = 0 - $1;
    return [$val] if $val < 0;
  }elsif($index =~ /^\[  ([+\-]?\d+)  ,  ([+\-]?\d+)  \]$/x){
    my $lower = parseIndices $1;
    my $upper = parseIndices $2;
    if(defined $lower and defined $upper and $$lower[0] <= $$upper[0]){
      return [$$lower[0] .. $$upper[0]];
    }
  }
  return undef;
}

&main(@ARGV);
