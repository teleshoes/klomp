#!/usr/bin/python
import curses
import curses.textpad
import time
import sys
import os
import subprocess
import threading
import csv
import re

import locale
locale.setlocale(locale.LC_ALL,"")

uiLock = threading.RLock()

KLOMP_LIST = os.environ['HOME'] + "/.klomplist"
KLOMP_CUR = os.environ['HOME'] + "/.klompcur"

usage = """Usage:
  %(exec)s -h | --help
    show this message
  %(exec)s [--debug]  [word word ..]
    interactive curses ui
    the textbox is initially set to "word word ..", if passed in
    --debug means exceptions dont exit, and the tmp file './out' will be rm'd
""" % {'exec': __file__}

ESCAPE = 27
TAB = ord('\t')

def main(args):
  sys.setrecursionlimit(100000) #HACK BUG WORKAROUND FUCKERS
  if len(args) == 2 and (args[1] == "-h" or args[1] == "--help"):
    print usage
    exit(0)

  debug = False
  if len(args) >= 2 and args[1] == "--debug":
    debug = True
    queryArgs = args[2:]
  else:
    queryArgs = args[1:]
  startingQuery = ' '.join(queryArgs)

  try:
    curses.wrapper(KlompUI(startingQuery).start)
  finally:
    if debug:
      os.system("rm out")
    else:
      os._exit(0)

quit = False
def quitSlowly():
  global quit
  quit = True
def maybeQuit():
  global quit
  if quit:
    exit(0)

class Attrs():
  def __init__(self):
    c = curses
    NONE = -1
    self.attrMap = {
      'textEdit': [c.COLOR_RED, c.COLOR_WHITE, [c.A_BOLD]],
      'query': [c.COLOR_GREEN, NONE, []],
      'cur': [c.COLOR_GREEN, c.COLOR_BLACK, []],
      'playList': [c.COLOR_BLUE, c.COLOR_WHITE, []],
      'prompt': [c.COLOR_MAGENTA, c.COLOR_BLACK, [c.A_BOLD]]
    }
    self.attrs = None
  def ensureAttrs(self):
    colorPairIndex = 1
    if self.attrs == None:
      self.attrs = {}
      curses.use_default_colors()
      for name, (fg, bg, otherAttrs) in self.attrMap.items():
        curses.init_pair(colorPairIndex, fg, bg)
        nameAttrs = curses.color_pair(colorPairIndex)
        colorPairIndex += 1
        for attr in otherAttrs:
          nameAttrs |= attr
        self.attrs[name] = nameAttrs
  def get(self, name):
    self.ensureAttrs()
    return self.attrs[name]
attrs = Attrs()

def millisNow():
  return int(round(time.time() * 1000))

def msg(s):
  os.system("echo '" + str(s) + "' >> out")

def readProc(cmdArr):
  out, err = subprocess.Popen(cmdArr, stdout=subprocess.PIPE).communicate()
  return out

class KeyReaderThread(threading.Thread):
  def __init__(self, stdscr, onGetSomeKeys):
    threading.Thread.__init__(self)
    self.stdscr = stdscr
    self.onGetSomeKeys = onGetSomeKeys
  def run(self):
    while True:
      keys = self.getSomeKeysBlocking()
      self.onGetSomeKeys(keys)
  def getch(self):
    key = self.stdscr.getch()
    return curses.KEY_ENTER if key == ord('\n') else key
  def getSomeKeysBlocking(self):
    keys = []

    self.stdscr.nodelay(0)
    keys.append(self.getch())

    self.stdscr.nodelay(1)
    while True:
      key = self.getch()
      if key == -1:
        break
      keys.append(key)
    return keys

class LinePrinter():
  def __init__(self, height, width, y, x, attrs=None):
    self.line = 0
    self.y = y
    self.x = x
    self.height = height
    self.width = width
    self.attrs = attrs
    self.win = curses.newwin(height, width, y, x)
  def updateSize(self):
    y, x = self.win.getmaxyx()
    self.height, self.width = y - self.y, x - self.x
  def isWindowFull(self):
    return self.line >= self.height
  def printLines(self, strLines, attrs=None):
    map(lambda line: self.printLine(line, attrs), strLines.splitlines())
  def printLine(self, line, attrs=None):
    line = line[:self.width]
    if attrs == None:
      attrs = self.attrs
    try:
      if attrs != None:
        self.win.addstr(self.line, 0, line, attrs)
      else:
        self.win.addstr(self.line, 0, line)
    except curses.error:
      pass
    self.line += 1
  def clear(self):
    self.win.erase()
    self.line = 0

class OffsetListDisplay():
  def __init__(self):
    self.offset = 0
  def checkOffset(self):
    limit = self.getOffsetLimit()
    limit = 0 if limit < 0 else limit
    if self.offset < 0:
      self.offset = 0
    elif self.offset > limit:
      self.offset = limit
  def addOffset(self, offset):
    prevOffset = self.offset
    self.offset += offset
    self.checkOffset()
    return self.offset != prevOffset
  def formatOffset(self):
    return '' if self.offset == 0 else " offset=%d" % self.offset
  def getOffsetLimit(self):
    return -1

class TextEdit(LinePrinter):
  def __init__(self, line, width, attrs = None):
    LinePrinter.__init__(self, 1, width, line, 0, attrs)
    self.preText = u""
    self.postText = u""
  def handleKeys(self, keys):
    text = ""
    cmds = []
    for key in keys:
      c = curses
      if key == c.KEY_HOME:
        self.postText = self.preText + self.postText
        self.preText = u""
      elif key == c.KEY_END:
        self.preText += self.postText
        self.postText = u""
      elif key == c.KEY_LEFT:
        self.postText = self.preText[-1:] + self.postText
        self.preText = self.preText[:-1]
      elif key == c.KEY_RIGHT:
        self.preText += self.postText[:1]
        self.postText = self.postText[1:]
      elif key == c.KEY_BACKSPACE:
        self.preText = self.preText[:-1]
      elif key == c.KEY_DC: #delete
        self.postText = self.postText[1:]
      elif key < 256:
        text += chr(key)
    self.preText += text.decode('utf8')
  def getCursorPos(self):
    length = len(self.preText)
    tabwidth = 8
    tabstop = 0
    for c in self.preText:
      tabstop = 1 + (tabstop % tabwidth)
      if c == "\t":
        length += tabwidth-tabstop
        tabstop = 0
      elif self.isFullWidth(c):
        length += 1
        tabstop += 1
    return length
  def isFullWidth(self, c):
    p = ord(c)
    return (False
       or (p >= 0x3041 and p <= 0xfa2d)
       or (p >= 0xfe30 and p <= 0xfe6b)
       or (p >= 0xff01 and p <= 0xff60)
       or (p >= 0xffe0 and p <= 0xffee)
    )
  def getText(self):
    return self.preText.encode('utf8') + self.postText.encode('utf8')
  def setText(self, text):
    self.preText = text.decode('utf8')
    self.postText = u""
  def updateText(self):
    self.clear()
    self.printLine(self.getText())
    self.win.noutrefresh()
  def updateCursor(self):
    pos = self.getCursorPos()
    self.win.move(0, pos)
    curses.setsyx(self.y, pos)

class Prompt(LinePrinter):
  def __init__(self, height, width, attrs=None):
    LinePrinter.__init__(self, height, width, 2, 0, attrs)
    self.shuffle = True
  def setSongEntries(self, songEntries):
    self.songCount = len(songEntries)
    os.system("rm /tmp/klomplist_* 2>/dev/null")
    self.tmpFile = "/tmp/klomplist_" + str(millisNow())

    with open(self.tmpFile, 'w') as f:
      f.writelines(songEntries)
  def update(self):
    self.clear()
    map(self.printLine, [
      "wrote %d -> %s" % (self.songCount, self.tmpFile),
      "",
      "q     - do nothing with these files"
      "enter - prepend files to KLOMPLIST",
      "a     - append files to KLOMPLIST",
      "o     - overwrite KLOMPLIST with files",
      "  notyet:"
      "  r     - REMOVE these files from KLOMPLIST",
      "",
      "shuffle => " + str(self.shuffle) + "  {space to toggle}",
      ""])
    self.win.noutrefresh()
  def maybeShuffleTmpFile(self):
    if self.shuffle:
      os.system("sort -R " + self.tmpFile + " -o " + self.tmpFile)
  def appendTmpFile(self):
    os.system("cat " + self.tmpFile + " >> " + KLOMP_LIST)
  def prependTmpFile(self):
    os.system("cat " + KLOMP_LIST + " >> " + self.tmpFile)
    self.replaceTmpFile()
  def replaceTmpFile(self):
    os.system("mv " + self.tmpFile + " " + KLOMP_LIST)
  def handleKeys(self, keys):
    c = curses
    for key in keys:
      if key == c.KEY_ENTER:
        self.maybeShuffleTmpFile()
        self.prependTmpFile()
        return True
      elif key > 0 and key < 256:
        ch = chr(key).lower()
        if ch == 'q':
          return True
        elif ch == 'a':
          self.maybeShuffleTmpFile()
          self.appendTmpFile()
          return True
        elif ch == 'o':
          self.maybeShuffleTmpFile()
          self.replaceTmpFile()
          return True
        elif ch == ' ':
          self.shuffle = not self.shuffle
    return False

class KlompLibs():
  def __init__(self):
    self.libPaths = {}
    self.flacmirrorPaths = {}
    self.initialized = False
    self.sep = "///\\\\\\"
    reSep = self.sep.replace('\\', '\\\\')
    self.songRe = re.compile(''
      + '(.*)'
      + reSep + 'artist=' + '(.*)'
      + reSep + 'album=' + '(.*)'
      + reSep + 'number=' + '(.*)'
      + reSep + 'title=' + '(.*)'
      + reSep + 'query=' + '(.*)'
    )
  def initLibs(self):
    if self.initialized == False:
      for lib in readProc(["klomp-lib"]).splitlines():
        self.libPaths[lib] = readProc(["klomp-lib", "-l", lib]).rstrip()
        self.flacmirrorPaths[lib] = readProc(["klomp-lib", "-f", lib]).rstrip()
      self.initialized = True
  def toString(self, song):
    path = self.toAbsPath(song)
    return (
        path +
        self.sep + "artist=" + song['artist'] +
        self.sep + "album=" + song['album'] +
        self.sep + "number=" + song['number'] +
        self.sep + "title=" + song['title'] +
        self.sep + "query=" + song['query'] + "\n")
  def fromString(self, s):
    song = {}
    m = self.songRe.match(s)
    if m:
      library, relpath = self.fromAbsPath(m.group(1))
      song['library'] = library
      song['relpath'] = relpath
      song['artist'] = m.group(2)
      song['album'] = m.group(3)
      song['number'] = m.group(4)
      song['title'] = m.group(5)
      song['query'] = m.group(6)
      return song
    else:
      return None
  def fromCurString(self, cur):
    curM = re.match(r'(\d+\.\d+) (\d+\.\d+) (.*)', cur, re.DOTALL)
    if curM:
      pos = curM.group(1)
      length = curM.group(2)
      curStr = curM.group(3)
      curStr = curStr.rstrip()
      curStr = curStr.replace('\n', self.sep)
      song = self.fromString(curStr)
      if song:
        song['len'] = length
        song['pos'] = pos
        return song
    return None
  def toAbsPath(self, song):
    self.initLibs()
    lib = song['library']
    relpath = song['relpath']
    path = self.libPaths[lib] + "/" + song['relpath']
    if not os.path.exists(path):
      flacmirrorPath = self.flacmirrorPaths[lib] + "/" + song['relpath']
      flacmirrorPath = self.flacToOgg(flacmirrorPath)
      if os.path.exists(flacmirrorPath):
        path = flacmirrorPath
    return path
  def fromAbsPath(self, path):
    self.initLibs()
    for lib in self.libPaths.keys():
      libPath = self.libPaths[lib] + '/'
      if path.startswith(libPath):
        library = lib
        relpath = path.replace(libPath, '', 1)
        return library, relpath
      flacmirrorPath = self.flacmirrorPaths[lib]
      if path.startswith(flacmirrorPath):
        library = lib
        relpath = path.replace(flacmirrorPath, '', 1)
        relpath = self.oggToFlac(relpath)
        return library, relpath
    return None, None
  def flacToOgg(self, s):
    return re.sub(r'\.flac$', '.ogg', s)
  def oggToFlac(self, s):
    return re.sub(r'\.ogg$', '.flac', s)
klompLibs = KlompLibs()

class QueryDisplay(LinePrinter, OffsetListDisplay):
  def __init__(self, height, width, attrs=None):
    LinePrinter.__init__(self, height, width, 1, 0, attrs)
    OffsetListDisplay.__init__(self)
  def getOffsetLimit(self):
    return len(self.songs) - self.height/3
  def setSongs(self, songs):
    self.songs = songs
  def getSongEntries(self):
    return map(klompLibs.toString, self.songs)
  def getSongBucket(self, s):
    return s['artist'] + '###' + s['album'] + '###' + s['library']
  def trimMid(self, s, lim, ellip):
    length = len(s)
    if length <= lim:
      return s
    else:
      ellipLen = len(ellip.decode('utf8'))
      left = lim/2
      right = length - lim/2 - lim%2 + ellipLen
      return s[:left] + ellip + s[right:]
  def padNumbers(self, songs):
    maxLen = max([len(s['number']) for s in songs])
    for s in songs:
      numLen = len(s['number'])
      prefix = ' ' * (maxLen - numLen)
      s['number'] = prefix + s['number']
  def formatSong(self, s):
    return ' ' + s['number'] + ':' + s['title']
  def formatSongBucket(self, s):
    prefix = ''
    sep1 = ' - '
    sep2 = ' ('
    suffix = ')'
    lib = s['library']
    limit = self.width - len(prefix + sep1 + sep2 + lib + suffix)
    artistLimit = limit/2 + limit%2
    albumLimit = limit/2
    artistLen = len(s['artist'])
    albumLen = len(s['album'])
    if artistLimit > artistLen:
      albumLimit += artistLimit - artistLen
      artistLimit = artistLen
    if albumLimit > albumLen:
      artistLimit += albumLimit - albumLen
      albumLimit = albumLen

    ellip = unichr(8230).encode('utf8') #HORIZONTAL ELLIPSIS
    artist = self.trimMid(s['artist'], artistLimit, ellip)
    album = self.trimMid(s['album'], albumLimit, ellip)
    return prefix + artist + sep1 + album + sep2 + lib + suffix
  def getSummary(self, songs):
    songLen = 0
    artists = dict()
    albums = dict()
    libs = dict()

    for s in songs:
      if s['artist'] not in artists:
        artists[s['artist']] = True
      if s['album'] not in albums:
        albums[s['album']] = True
      if s['library'] not in libs:
        libs[s['artist']] = True
      songLen += 1
    return "%d Songs  %d Artists  %d Albums" % (
      songLen, len(artists), len(albums))
  def update(self):
    self.clear()
    self.updateSize()
 
    buckets = dict()
    bucketDisplays = dict()
    bucketOrder = []

    self.checkOffset()
    count = 0
    limit = self.height - 1
    for song in self.songs[self.offset:self.offset+limit]:
      b = self.getSongBucket(song)
      if b not in buckets:
        buckets[b] = []
        bucketDisplays[b] = self.formatSongBucket(song)
        bucketOrder.append(b)
      buckets[b].append(song)

    self.printLine(self.getSummary(self.songs) + self.formatOffset())
    for bucket in bucketOrder:
      if self.isWindowFull():
        break
      self.printLine(bucketDisplays[bucket])
      bucketSongs = buckets[bucket]
      self.padNumbers(bucketSongs)
      for fmtSong in [self.formatSong(s) for s in bucketSongs]:
        self.printLine(fmtSong)
    self.win.noutrefresh()

class PlayListDisplay(LinePrinter, OffsetListDisplay):
  def __init__(self, height, width, attrs=None):
    LinePrinter.__init__(self, height, width, 1, 0, attrs)
    OffsetListDisplay.__init__(self)
  def getOffsetLimit(self):
    if self.last == True:
      return self.lastIndex - self.height/2
    else:
      return sys.maxint
  def getLines(self, n):
    lines = []
    self.last = False
    try:
      with open(KLOMP_LIST, 'r') as f:
        while n > 0:
          line = f.readline()
          if not line:
            self.last = True
            self.lastIndex = len(lines)-1
            break
          else:
            lines.append(line)
            n -= 1
      return lines
    except:
      return []
  def handleKeys(self, keys):
    c = curses
    klompcmds = {
      ' ': 'pause',
      'z': 'prev',
      'x': 'next',
      'r': 'shuffle',
      'b': 'breaks toggle',
      'a': 'seek -60',
      's': 'seek 60'}
    for key in keys:
      if key > 0 and key < 256:
        ch = chr(key).lower()
        if ch == 'q':
          quitSlowly()
        elif ch in klompcmds:
          klompcmd = klompcmds[ch]
          os.system('nohup klomp-cmd ' + klompcmd + ' 1>/dev/null 2>&1 &')
  def formatSong(self, song):
    sep = unichr(8942).encode('utf8') #VERTICAL ELLIPSIS
    sep = ' ' + sep + ' '
    return (''
      + song['title'] + sep
      + song['artist'] + sep
      + song['album']
    )
  def maybeFormatSongString(self, s):
    song = klompLibs.fromString(s)
    if song:
      return self.formatSong(song)
    return 'COULD NOT FORMAT SONG: ' + s
  def maybeFormatCur(self):
    song = {}
    try:
      with open(KLOMP_CUR, 'r') as f:
        cur = f.read()
    except:
      return 'NO CUR'
    song = klompLibs.fromCurString(cur)
    if song:
      return "%.0f/%.0f '%s' %s\n%s" % (
        float(song['pos']), float(song['len']),
        song['library'], song['relpath'],
        self.formatSong(song))
    return 'INVALID CUR'
  def update(self):
    self.clear()
    self.updateSize()
    self.printLines(self.maybeFormatCur(), attrs.get('cur'))
    lines = self.getLines(self.height + self.offset)[self.offset:]
    for line in lines:
      self.printLine(self.maybeFormatSongString(line))
    self.win.noutrefresh()

class KlompQuery():
  def __init__(self):
    self.cols = ['artist', 'album', 'number', 'title', 'relpath', 'library']
    self.query = None
  def buildQueryCmd(self):
    cmd = ["klomp-db", "-s", self.query]
    for col in self.cols:
      cmd.append("--col")
      cmd.append(col)
    return cmd
  def parseCsv(self, string, colNames):
    return list(csv.DictReader(string.split("\n"), fieldnames=colNames,
      delimiter=',', quotechar='"'))
  def maybePerformQuery(self, query):
    if self.query != query:
      self.query = query
      return self.performQuery()
    else:
      return None
  def performQuery(self):
    songs = self.parseCsv(readProc(self.buildQueryCmd()), self.cols)
    for s in songs:
      s['query'] = self.query
      s['number'] = re.sub('^0+', '', s['number'])
    return songs

class Mode: Query, PlayList, Prompt = range(3)

class KlompUI():
  def __init__(self, startingQuery):
    self.klompQuery = KlompQuery()
    self.mode = Mode.Query
    self.startingQuery = startingQuery
  def start(self, stdscr):
    self.stdscr = stdscr
    height, width = self.stdscr.getmaxyx()
    self.textEdit = TextEdit(0, width, attrs.get('textEdit'))
    self.queryDisplay = QueryDisplay(height, width, attrs.get('query'))
    self.playListDisplay = PlayListDisplay(height, width, attrs.get('playList'))
    self.prompt = Prompt(height, width, attrs.get('prompt'))
    KeyReaderThread(self.stdscr, self.onGetSomeKeys).start()
    if self.startingQuery != None and len(self.startingQuery) > 0:
      self.textEdit.setText(self.startingQuery)

    self.enterQueryMode()
    while True:
      maybeQuit()
      if self.mode == Mode.Query:
        self.updateSongs()
      elif self.mode == Mode.PlayList:
        self.updatePlayListDisplay()
      time.sleep(1)
  def updateSongs(self):
    songs = self.klompQuery.maybePerformQuery(self.textEdit.getText())
    if songs != None:
      self.queryDisplay.setSongs(songs)
      self.updateQueryDisplay()
  def enterQueryMode(self):
    self.updateSongs()
    self.mode = Mode.Query
    self.clear()
    self.updateQueryDisplay()
    self.updateTextEditDisplay()
  def enterPlayListMode(self):
    self.updateSongs()
    self.mode = Mode.PlayList
    self.clear()
    self.updatePlayListDisplay()
  def enterPromptMode(self):
    self.updateSongs()
    self.mode = Mode.Prompt 
    songEntries = self.queryDisplay.getSongEntries()
    self.prompt.setSongEntries(songEntries)
    self.clear()
    self.updatePrompt()
  def onCommandKey(self, key):
    c = curses
    offsetKeys = {
      c.KEY_UP: -1,
      c.KEY_DOWN: 1,
      c.KEY_PPAGE: -10,
      c.KEY_NPAGE: 10}

    if self.mode == Mode.Query:
      if key == TAB:
        self.enterPlayListMode()
      elif key == c.KEY_ENTER:
        self.enterPromptMode()
      elif key == ESCAPE:
        quitSlowly()
      elif key in offsetKeys:
        if self.queryDisplay.addOffset(offsetKeys[key]):
          self.updateQueryDisplay()
    elif self.mode == Mode.PlayList:
      if key == TAB:
        self.enterQueryMode()
      elif key in offsetKeys:
        if self.playListDisplay.addOffset(offsetKeys[key]):
          self.updatePlayListDisplay()
  def onGetSomeKeys(self, keys):
    if self.mode == Mode.Prompt:
      if self.prompt.handleKeys(keys):
        self.enterQueryMode()
      else:
        self.updatePrompt()
    else:
      cmdKeys, otherKeys = self.splitCmdKeys(keys)
      if self.mode == Mode.Query:
        self.textEdit.handleKeys(otherKeys)
        for cmd in cmdKeys:
          self.onCommandKey(cmd)
        self.updateTextEditDisplay()
      elif self.mode == Mode.PlayList:
        for cmd in cmdKeys:
          self.onCommandKey(cmd)
        self.playListDisplay.handleKeys(otherKeys)
  def splitCmdKeys(self, keys):
    c = curses
    commands = [c.KEY_ENTER, ESCAPE, TAB,
      c.KEY_UP, c.KEY_DOWN, c.KEY_PPAGE, c.KEY_NPAGE]
    cmdKeys, otherKeys = [], []

    for key in keys:
      if key in commands:
        cmdKeys.append(key)
      else:
        otherKeys.append(key)
    return (cmdKeys, otherKeys)
  def clear(self):
    with uiLock:
      self.textEdit.clear()
      self.queryDisplay.clear()
      self.prompt.clear()
  def updateQueryDisplay(self):
    with uiLock:
      self.queryDisplay.update()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updateTextEditDisplay(self):
    with uiLock:
      self.textEdit.updateText()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updatePlayListDisplay(self):
    with uiLock:
      self.playListDisplay.update()
      curses.doupdate()
  def updatePrompt(self):
    with uiLock:
      self.prompt.update()
      curses.doupdate()

if __name__ == "__main__":
  main(sys.argv)
