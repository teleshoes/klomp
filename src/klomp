#!/usr/bin/python
from __future__ import with_statement
from itertools import cycle
from random import random
from operator import itemgetter
import curses
import curses.textpad
import time
import sys
import os
import os.path
import subprocess
import threading
import csv
import re
import locale
locale.setlocale(locale.LC_ALL,"")

uiLock = threading.RLock()

KLOMP_LIST = os.popen('klomp-files -n list').read()
KLOMP_CUR = os.popen('klomp-files -n cur').read()

usage = """Usage:
  %(exec)s -h | --help
    show this message
  %(exec)s [--once] [--playlist] [--debug]  [word word ..]
    interactive curses ui
    the textbox is initially set to "word word ..", if passed in
    --once exits after prompt menu instead of returning to query
    --playlist starts in playlist mode
    --debug means exceptions dont exit, and the tmp file './out' will be rm'd
""" % {'exec': __file__}

ESCAPE = 27
TAB = ord('\t')

def main(args):
  sys.setrecursionlimit(100000) #HACK BUG WORKAROUND FUCKERS
  args = args[1:]

  if len(args) == 1 and (args[0] == "-h" or args[0] == "--help"):
    print usage
    exit(0)

  once = False
  if len(args) >= 1 and (args[0] == "--once"):
    once = True
    args = args[1:]

  initialMode = Mode.Query
  if len(args) >= 1 and (args[0] == "--playlist"):
    initialMode = Mode.PlayList
    args = args[1:]

  debug = False
  if len(args) >= 1 and args[0] == "--debug":
    debug = True
    args = args[1:]

  startingQuery = ' '.join(args)

  try:
    curses.wrapper(KlompUI(once, startingQuery, initialMode).start)
  finally:
    if debug:
      os.system("rm out")
    else:
      os._exit(0)

quit = False
def quitSlowly():
  global quit
  quit = True
def maybeQuit():
  global quit
  if quit:
    exit(0)
def daemonExec(execName, args):
  if not os.fork():
    try:
      os.setsid()
    except:
      pass
    os.chdir("/")
    null = os.open("/dev/null", os.O_RDWR)
    os.dup2(null, 0)
    os.dup2(null, 1)
    os.dup2(null, 2)
    os.close(null)
    exe = subprocess.Popen(['which', execName],
      stdout=subprocess.PIPE).communicate()[0]
    exe = exe.rstrip()
    args.insert(0, exe)
    os.execv(exe, args)


class Attrs():
  def __init__(self):
    c = curses
    NONE = -1
    self.attrMap = {
      'textEdit': [c.COLOR_RED, c.COLOR_WHITE, [c.A_BOLD]],
      'query': [c.COLOR_GREEN, NONE, []],
      'cur': [c.COLOR_GREEN, c.COLOR_BLACK, []],
      'playList': [c.COLOR_BLUE, c.COLOR_WHITE, []],
      'prompt': [c.COLOR_MAGENTA, c.COLOR_BLACK, [c.A_BOLD]]
    }
    self.attrs = None
  def ensureAttrs(self):
    colorPairIndex = 1
    if self.attrs == None:
      self.attrs = {}
      curses.use_default_colors()
      for name, (fg, bg, otherAttrs) in self.attrMap.items():
        curses.init_pair(colorPairIndex, fg, bg)
        nameAttrs = curses.color_pair(colorPairIndex)
        colorPairIndex += 1
        for attr in otherAttrs:
          nameAttrs |= attr
        self.attrs[name] = nameAttrs
  def get(self, name):
    self.ensureAttrs()
    return self.attrs[name]
attrs = Attrs()

def pad2(n):
  if n < 10:
    return "0" + str(n)
  else:
    return str(n)

def fmtTime(t):
  try:
    t = int(float(t))
  except:
    return "??:??"
  s = t%60
  m = t/60%60
  h = t/60/60
  if h > 0:
    return str(h) + ":" + pad2(m) + ":" + pad2(s)
  else:
    return str(m) + ":" + pad2(s)
  return fmt

def millisNow():
  return int(round(time.time() * 1000))

def msg(s):
  f = open("out", "a")
  f.write(str(s))
  f.close()

class KeyReaderThread(threading.Thread):
  def __init__(self, stdscr, onGetSomeKeys):
    threading.Thread.__init__(self)
    self.stdscr = stdscr
    self.onGetSomeKeys = onGetSomeKeys
  def run(self):
    while True:
      keys = self.getSomeKeysBlocking()
      self.onGetSomeKeys(keys)
  def getch(self):
    key = self.stdscr.getch()
    return curses.KEY_ENTER if key == ord('\n') else key
  def getSomeKeysBlocking(self):
    keys = []

    self.stdscr.nodelay(0)
    keys.append(self.getch())

    self.stdscr.nodelay(1)
    while True:
      key = self.getch()
      if key == -1:
        break
      keys.append(key)
    return keys

class LinePrinter():
  def __init__(self, height, width, y, x, attrs=None):
    self.line = 0
    self.y = y
    self.x = x
    self.height = height
    self.width = width
    self.attrs = attrs
    self.win = curses.newwin(height, width, y, x)
  def updateSize(self):
    y, x = self.win.getmaxyx()
    self.height, self.width = y - self.y, x - self.x
  def isWindowFull(self):
    return self.line >= self.height
  def printLines(self, strLines, attrs=None):
    map(lambda line: self.printLine(line, attrs), strLines.splitlines())
  def printLine(self, line, attrs=None):
    line = line[:self.width]
    if attrs == None:
      attrs = self.attrs
    try:
      if attrs != None:
        self.win.addstr(self.line, 0, line, attrs)
      else:
        self.win.addstr(self.line, 0, line)
    except curses.error:
      pass
    self.line += 1
  def clear(self):
    self.win.erase()
    self.line = 0

class OffsetListDisplay():
  def __init__(self):
    self.offset = 0
  def checkOffset(self):
    limit = self.getOffsetLimit()
    limit = 0 if limit < 0 else limit
    if self.offset < 0:
      self.offset = 0
    elif self.offset > limit:
      self.offset = limit
  def addOffset(self, offset):
    prevOffset = self.offset
    self.offset += offset
    self.checkOffset()
    return self.offset != prevOffset
  def formatOffset(self):
    return '' if self.offset == 0 else " offset=%d" % self.offset
  def getOffsetLimit(self):
    return -1

class TextEdit(LinePrinter):
  def __init__(self, line, width, attrs = None):
    LinePrinter.__init__(self, 1, width, line, 0, attrs)
    self.preText = u""
    self.postText = u""
  def handleKeys(self, keys):
    text = ""
    cmds = []
    for key in keys:
      c = curses
      if key == c.KEY_HOME:
        self.postText = self.preText + self.postText
        self.preText = u""
      elif key == c.KEY_END:
        self.preText += self.postText
        self.postText = u""
      elif key == c.KEY_LEFT:
        self.postText = self.preText[-1:] + self.postText
        self.preText = self.preText[:-1]
      elif key == c.KEY_RIGHT:
        self.preText += self.postText[:1]
        self.postText = self.postText[1:]
      elif key == c.KEY_BACKSPACE:
        self.preText = self.preText[:-1]
      elif key == c.KEY_DC: #delete
        self.postText = self.postText[1:]
      elif key < 256:
        text += chr(key)
    self.preText += text.decode('utf8')
  def getCursorPos(self):
    length = len(self.preText)
    tabwidth = 8
    tabstop = 0
    for c in self.preText:
      tabstop = 1 + (tabstop % tabwidth)
      if c == "\t":
        length += tabwidth-tabstop
        tabstop = 0
      elif self.isFullWidth(c):
        length += 1
        tabstop += 1
    return length
  def isFullWidth(self, c):
    p = ord(c)
    return (False
       or (p >= 0x3041 and p <= 0xfa2d)
       or (p >= 0xfe30 and p <= 0xfe6b)
       or (p >= 0xff01 and p <= 0xff60)
       or (p >= 0xffe0 and p <= 0xffee)
    )
  def getText(self):
    return self.preText.encode('utf8') + self.postText.encode('utf8')
  def setText(self, text):
    self.preText = text.decode('utf8')
    self.postText = u""
  def updateText(self):
    self.clear()
    self.printLine(self.getText())
    self.win.noutrefresh()
  def updateCursor(self):
    pos = self.getCursorPos()
    self.win.move(0, pos)
    curses.setsyx(self.y, pos)

class KlompListHandler():
  def readEntries(self):
    try:
      with open(KLOMP_LIST, 'r') as f:
        return f.readlines()
    except IOError:
      return []
  def writeEntries(self, entries, mode):
    with open(KLOMP_LIST, mode) as f:
      f.writelines(entries)

  def append(self, entries):
    self.writeEntries(entries, 'a')
  def prepend(self, entries):
    self.writeEntries(entries + self.readEntries(), 'w')
  def overwrite(self, entries):
    self.writeEntries(entries, 'w')

class Prompt(LinePrinter):
  def __init__(self, height, width, attrs=None):
    LinePrinter.__init__(self, height, width, 2, 0, attrs)
    self.klompListHandler = KlompListHandler()
    self.sortOrders = ["shuffle", "artist/album/number", "album/number"]
    self.sortFunctions = {
      "shuffle":             lambda s: random(),
      "artist/album/number": lambda s: (s['artist'], s['album'], self.num(s)),
      "album/number":        lambda s: (s['album'], self.num(s))
    }
  def num(self, s):
    m = re.search('[0-9]+', s['number'])
    if m:
      return int(m.group(0))
    else:
      return 0
  def resetSortOrder(self):
    self.sortOrderItr = cycle(self.sortOrders)
    self.nextSortOrder()
  def nextSortOrder(self):
    self.sortOrder = self.sortOrderItr.next()
  def setSongs(self, songs):
    self.resetSortOrder()
    self.songs = songs
  def update(self):
    self.clear()
    map(self.printLine, [
      "selected %d songs" % (len(self.songs)),
      "",
      "q/esc - do nothing with these files",
      "enter - prepend files to KLOMPLIST",
      "a     - append files to KLOMPLIST",
      "o     - overwrite KLOMPLIST with files",
      "  notyet:"
      "  r     - REMOVE these files from KLOMPLIST",
      "",
      "sort => %s" % (self.sortOrder),
      "{space to cycle: %s}" % (str(self.sortOrders)),
      ""])
    self.win.noutrefresh()
  def sortSongs(self):
    self.songs = sorted(self.songs, key=self.sortFunctions[self.sortOrder])
  def applySongs(self, mode):
    self.sortSongs()
    entries = map(klompLibs.toString, self.songs)

    if mode == "append":
      self.klompListHandler.append(entries)
    elif mode == "prepend":
      self.klompListHandler.prepend(entries)
    elif mode == "overwrite":
      self.klompListHandler.overwrite(entries)

    self.songs = []
  def handleKeys(self, keys):
    c = curses
    for key in keys:
      if key == c.KEY_ENTER:
        self.applySongs("prepend")
        return True
      elif key == ESCAPE:
        return True
      elif key > 0 and key < 256:
        ch = chr(key).lower()
        if ch == 'q':
          return True
        elif ch == 'a':
          self.applySongs("append")
          return True
        elif ch == 'o':
          self.applySongs("overwrite")
          return True
        elif ch == ' ':
          self.nextSortOrder()
    return False

class KlompLibs():
  def __init__(self):
    self.sep = "///\\\\\\"
    reSep = self.sep.replace('\\', '\\\\')
    self.songRe = re.compile('([^@]*)@(.*)')
    self.attCols = ["artist", "album", "number", "title", "duration", "query"]
    attColsRe = "|".join(self.attCols)
    self.attRe = re.compile("(" + attColsRe + ")=(.*)")
  def toString(self, song):
    return (
        song['library'] + '@' + song['relpath'] +
        self.sep + "artist=" + song['artist'] +
        self.sep + "album=" + song['album'] +
        self.sep + "number=" + song['number'] +
        self.sep + "title=" + song['title'] +
        self.sep + "duration=" + song['duration'] +
        self.sep + "query=" + song['query'] + "\n")
  def fromString(self, s):
    song = {}
    m = self.songRe.match(s)
    if m:
      song['library'] = m.group(1)
      info = m.group(2).split(self.sep)
      if len(info) > 0:
        song['relpath'] = info[0]
        info = info[1:]
      for att in self.attCols:
        song[att] = ''
      for att in info:
        attM = self.attRe.match(att)
        if attM:
          song[attM.group(1)] = attM.group(2)
      return song
    else:
      return None
  def fromCurString(self, cur):
    curM = re.match(r'(\d+\.\d+) (\d+\.\d+) (.*)', cur, re.DOTALL)
    if curM:
      pos = curM.group(1)
      length = curM.group(2)
      curStr = curM.group(3)
      curStr = curStr.rstrip()
      curStr = curStr.replace('\n', self.sep)
      song = self.fromString(curStr)
      if song:
        song['len'] = length
        song['pos'] = pos
        return song
    return None
klompLibs = KlompLibs()

class QueryDisplay(LinePrinter, OffsetListDisplay):
  def __init__(self, height, width, attrs=None):
    LinePrinter.__init__(self, height, width, 1, 0, attrs)
    OffsetListDisplay.__init__(self)
  def getOffsetLimit(self):
    return len(self.songs) - self.height/3
  def setSongs(self, songs):
    self.songs = songs
  def getSongs(self):
    return self.songs
  def getSongBucket(self, s):
    return s['artist'] + '###' + s['album'] + '###' + s['library']
  def trimMid(self, s, lim, ellip):
    length = len(s)
    if length <= lim:
      return s
    else:
      ellipLen = len(ellip.decode('utf8'))
      left = lim/2
      right = length - lim/2 - lim%2 + ellipLen
      return s[:left] + ellip + s[right:]
  def padNumbers(self, songs):
    maxLen = max([len(s['number']) for s in songs])
    for s in songs:
      numLen = len(s['number'])
      prefix = ' ' * (maxLen - numLen)
      s['number'] = prefix + s['number']
  def formatSong(self, s):
    dur = fmtTime(s['duration'])
    return ' ' + s['number'] + ':' + s['title'] + ' (' + dur + ')'
  def formatSongBucket(self, s):
    prefix = ''
    sep1 = ' - '
    sep2 = ' ('
    suffix = ')'
    lib = s['library']
    limit = self.width - len(prefix + sep1 + sep2 + lib + suffix)
    artistLimit = limit/2 + limit%2
    albumLimit = limit/2
    artistLen = len(s['artist'])
    albumLen = len(s['album'])
    if artistLimit > artistLen:
      albumLimit += artistLimit - artistLen
      artistLimit = artistLen
    if albumLimit > albumLen:
      artistLimit += albumLimit - albumLen
      albumLimit = albumLen

    ellip = unichr(8230).encode('utf8') #HORIZONTAL ELLIPSIS
    artist = self.trimMid(s['artist'], artistLimit, ellip)
    album = self.trimMid(s['album'], albumLimit, ellip)
    return prefix + artist + sep1 + album + sep2 + lib + suffix
  def getSummary(self, songs):
    songLen = 0
    artists = dict()
    albums = dict()
    libs = dict()

    for s in songs:
      if s['artist'] not in artists:
        artists[s['artist']] = True
      if s['album'] not in albums:
        albums[s['album']] = True
      if s['library'] not in libs:
        libs[s['artist']] = True
      songLen += 1
    return "%d Songs  %d Artists  %d Albums" % (
      songLen, len(artists), len(albums))
  def updateInitialMessage(self):
    self.clear()
    self.updateSize()
    self.printLines("""
      TAB to view playlist
      ENTER prompts what to do with songs selected by query
        {all songs in default libs are selected by default}
      Searching is case insensitive against title, album or artist.
      Guess columns allow for unicode transforms and script transliteration.
       Query syntax:
       WORD: double-quoted string or non-whitespace, non-special string
        ["a snack"] => a snack
        ["@l^""$"] => @l^"$   {"" is a literal " in quoted string}
       NOT: a ! at the start of a WORD
        [love !"the beatles"] => love AND NOT(the beatles)
       COLS: @ followed by any of tlagpn at the start of a WORD
        t:title  l:album  a:artist  g:genre  p:path  n:number
        [@ap"the beatles"] => COLS{ARTIST, PATH}(the beatles)
       AND: whitespace or &&
        [white && album , the] => white AND album AND , AND the
       OR: || or ++
        [regina || spektor ++ the beatles] =>
          regina OR spektor OR (the AND beatles)
       START: ^ at the beginning of a WORD
        [^"come together" ^abbey] => START(come together) AND START(abbey)
       END: $ at the end of a WORD
        [beatles love$ can't "a hard day's night"$] =>
          beatles AND END(love) AND can't AND END(a hard day's night)
       LIBRARY: @all or @ followed by a library name at the query start
        [@all neil gaiman] => LIBRARY(ALL) neil AND gaiman
        [@books neil gaiman] => LIBRARY(books) neil AND gaiman
        [neil @d gaiman] => LIBRARY(ALL) neil AND @d AND gaiman
      """)
    self.win.noutrefresh()
  def update(self):
    self.clear()
    self.updateSize()
 
    buckets = dict()
    bucketDisplays = dict()
    bucketOrder = []

    self.checkOffset()
    count = 0
    limit = self.height - 1
    for song in self.songs[self.offset:self.offset+limit]:
      b = self.getSongBucket(song)
      if b not in buckets:
        buckets[b] = []
        bucketDisplays[b] = self.formatSongBucket(song)
        bucketOrder.append(b)
      buckets[b].append(song)

    self.printLine(self.getSummary(self.songs) + self.formatOffset())
    for bucket in bucketOrder:
      if self.isWindowFull():
        break
      self.printLine(bucketDisplays[bucket])
      bucketSongs = buckets[bucket]
      self.padNumbers(bucketSongs)
      for fmtSong in [self.formatSong(s) for s in bucketSongs]:
        self.printLine(fmtSong)
    self.win.noutrefresh()

class PlayListDisplay(LinePrinter, OffsetListDisplay):
  def __init__(self, height, width, attrs=None):
    LinePrinter.__init__(self, height, width, 1, 0, attrs)
    OffsetListDisplay.__init__(self)
  def getOffsetLimit(self):
    if self.last == True:
      return self.lastIndex - self.height/2
    else:
      return sys.maxint
  def getLines(self, n):
    lines = []
    self.last = False
    try:
      with open(KLOMP_LIST, 'r') as f:
        while n > 0:
          line = f.readline()
          if not line:
            self.last = True
            self.lastIndex = len(lines)-1
            break
          else:
            lines.append(line)
            n -= 1
      return lines
    except:
      return []
  def handleKeys(self, keys):
    c = curses
    klompcmds = {
      ord(' '):    ['pause'],
      ord('z'):    ['prev'],
      ord('x'):    ['next'],
      ord('r'):    ['shuffle'],
      ord('b'):    ['breaks', 'toggle'],
      ord('9'):    ['volume',  '-1', '0'],
      ord('0'):    ['volume',  '+1', '0'],
      ord('5'):    ['volume',  '10', '1'],
      ord('6'):    ['volume',  '25', '1'],
      ord('7'):    ['volume',  '75', '1'],
      ord('8'):    ['volume', '100', '1'],
      ord('a'):    ['seek', '-60'],
      ord('s'):    ['seek', '60'],
      c.KEY_LEFT:  ['seek', '-10'],
      c.KEY_RIGHT: ['seek', '10']}
    for key in keys:
      if key > 0 and key < 256:
        ch = chr(key).lower()
        key = ord(ch)
      if key == ord('q'):
        quitSlowly()
      elif key in klompcmds:
        daemonExec('klomp-cmd', klompcmds[key])
  def formatSong(self, song):
    sep = unichr(8942).encode('utf8') #VERTICAL ELLIPSIS
    bigSep = ' ' + sep + ' '
    dur = fmtTime(song['duration'])
    return (''
      + song['number'] + sep
      + song['title'] + bigSep
      + song['title'] + " (" + dur + ")" + bigSep
      + song['artist'] + bigSep
      + song['album']
    )
  def maybeFormatSongString(self, s):
    song = klompLibs.fromString(s)
    if song:
      return self.formatSong(song)
    return 'COULD NOT FORMAT SONG: ' + s
  def maybeFormatCur(self):
    song = {}
    try:
      with open(KLOMP_CUR, 'r') as f:
        cur = f.read()
    except:
      return 'NO CUR'
    song = klompLibs.fromCurString(cur)
    if song:
      return "%.0f/%.0f '%s' %s\n%s" % (
        float(song['pos']), float(song['len']),
        song['library'], song['relpath'],
        self.formatSong(song))
    return 'INVALID CUR'
  def update(self):
    self.clear()
    self.updateSize()
    self.printLines(self.maybeFormatCur(), attrs.get('cur'))
    lines = self.getLines(self.height + self.offset)[self.offset:]
    for line in lines:
      self.printLine(self.maybeFormatSongString(line))
    self.win.noutrefresh()

class KlompQuery():
  def __init__(self):
    self.cols = ['artist', 'album', 'number', 'title',
      'duration', 'relpath', 'library']
    self.query = None
  def buildQueryCmd(self):
    cmd = ["klomp-db", "-s", self.query]
    for col in self.cols:
      cmd.append("--col")
      cmd.append(col)
    return cmd
  def parseCsv(self, string, colNames):
    return list(csv.DictReader(string.split("\n"), fieldnames=colNames,
      delimiter=',', quotechar='"'))
  def maybePerformQuery(self, query):
    if self.query != query:
      self.query = query
      return self.performQuery()
    else:
      return None

  def getSongs(self):
    cmdArr = self.buildQueryCmd()
    out, err = subprocess.Popen(cmdArr,
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE,
      ).communicate()
    if err:
      raise IOError(err)
    return self.parseCsv(out, self.cols)
  def getError(self):
    return self.error
  def performQuery(self):
    try:
      songs = self.getSongs()
      for s in songs:
        s['query'] = self.query
        s['number'] = re.sub('^0+', '', s['number'])
      return songs
    except IOError as e:
      self.query = None
      errorSong = {}
      for c in self.cols:
        errorSong[c] = ''
      errorSong['title'] = str(e)
      errorSong['artist'] = '<error>'
      return [errorSong]

class Mode: Query, PlayList, Prompt = range(3)

class KlompUI():
  def __init__(self, once, startingQuery, initialMode):
    self.once = once
    self.klompQuery = KlompQuery()
    self.mode = initialMode
    self.startingQuery = startingQuery
    self.initialMessage = True
  def start(self, stdscr):
    self.stdscr = stdscr
    height, width = self.stdscr.getmaxyx()
    self.textEdit = TextEdit(0, width, attrs.get('textEdit'))
    self.queryDisplay = QueryDisplay(height, width, attrs.get('query'))
    self.queryDisplay.setSongs([])
    self.playListDisplay = PlayListDisplay(height, width, attrs.get('playList'))
    self.prompt = Prompt(height, width, attrs.get('prompt'))
    KeyReaderThread(self.stdscr, self.onGetSomeKeys).start()
    if self.startingQuery != None and len(self.startingQuery) > 0:
      self.textEdit.setText(self.startingQuery)
    self.setMode(self.mode)

    while True:
      maybeQuit()
      if self.mode == Mode.Query:
        self.updateSongs()
      elif self.mode == Mode.PlayList:
        self.updatePlayListDisplay()
      time.sleep(1)
  def updateSongs(self):
    text = self.textEdit.getText()
    if text != "":
      self.initialMessage = False
    if self.initialMessage:
      self.updateInitialMessage()
    else:
      songs = self.klompQuery.maybePerformQuery(self.textEdit.getText())
      if songs != None:
        self.queryDisplay.setSongs(songs)
        self.updateQueryDisplay()
  def setMode(self, mode):
    self.mode = mode

    self.updateSongs()
    self.clear()

    if self.mode == Mode.Query:
      self.updateQueryDisplay()
      self.updateTextEditDisplay()
    elif self.mode == Mode.PlayList:
      self.updatePlayListDisplay()
    elif self.mode == Mode.Prompt:
      self.prompt.setSongs(self.queryDisplay.getSongs())
      self.updatePrompt()
  def onCommandKey(self, key):
    c = curses
    offsetKeys = {
      c.KEY_UP: -1,
      c.KEY_DOWN: 1,
      c.KEY_PPAGE: -10,
      c.KEY_NPAGE: 10}

    if self.mode == Mode.Query:
      if key == TAB:
        self.setMode(Mode.PlayList)
      elif key == c.KEY_ENTER:
        self.initialMessage = False
        self.setMode(Mode.Prompt)
      elif key == ESCAPE:
        quitSlowly()
      elif key in offsetKeys:
        if self.queryDisplay.addOffset(offsetKeys[key]):
          self.updateQueryDisplay()
    elif self.mode == Mode.PlayList:
      if key == TAB:
        self.setMode(Mode.Query)
      elif key in offsetKeys:
        if self.playListDisplay.addOffset(offsetKeys[key]):
          self.updatePlayListDisplay()
  def onGetSomeKeys(self, keys):
    if self.mode == Mode.Prompt:
      if self.prompt.handleKeys(keys):
        if self.once:
          quitSlowly()
        else:
          self.setMode(Mode.Query)
      else:
        self.updatePrompt()
    else:
      cmdKeys, otherKeys = self.splitCmdKeys(keys)
      if self.mode == Mode.Query:
        self.textEdit.handleKeys(otherKeys)
        for cmd in cmdKeys:
          self.onCommandKey(cmd)
        self.updateTextEditDisplay()
      elif self.mode == Mode.PlayList:
        for cmd in cmdKeys:
          self.onCommandKey(cmd)
        self.playListDisplay.handleKeys(otherKeys)
  def splitCmdKeys(self, keys):
    c = curses
    commands = [c.KEY_ENTER, ESCAPE, TAB,
      c.KEY_UP, c.KEY_DOWN, c.KEY_PPAGE, c.KEY_NPAGE]
    cmdKeys, otherKeys = [], []

    for key in keys:
      if key in commands:
        cmdKeys.append(key)
      else:
        otherKeys.append(key)
    return (cmdKeys, otherKeys)
  def clear(self):
    with uiLock:
      self.textEdit.clear()
      self.queryDisplay.clear()
      self.prompt.clear()
  def updateQueryDisplay(self):
    with uiLock:
      self.queryDisplay.update()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updateInitialMessage(self):
    with uiLock:
      self.queryDisplay.updateInitialMessage()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updateTextEditDisplay(self):
    with uiLock:
      self.textEdit.updateText()
      self.textEdit.updateCursor()
      curses.doupdate()
  def updatePlayListDisplay(self):
    with uiLock:
      self.playListDisplay.update()
      curses.doupdate()
  def updatePrompt(self):
    with uiLock:
      self.prompt.update()
      curses.doupdate()

if __name__ == "__main__":
  main(sys.argv)
