#!/usr/bin/perl
use strict;
use warnings;
use lib "/opt/klomp/lib";
use Sys::Hostname;
use Klomp::Files;

my $klomplayerExec = 'klomplayer';
my $FILES = Klomp::Files::allKlompFiles();

my $usage = "Usage:
  $0 -h - show this message
  $0 playlist - print active playlist name
     the contents of $$FILES{plname} if present, otherwise 'main'
  $0 playlist PLNAME - activate/deactivate playlist PLNAME
     PLNAME cannot be 'main', and may contain only letters, numbers, or _s

     A 'playlist' is three files, {CURRENT, LIST, AND HISTORY}
     Playlists are stored in three dirs:
       -active: $ENV{HOME}/
       -main when non-active: $$FILES{pldir}main/
       -PLNAME when non-active: $$FILES{pldir}PLNAME/

     The name of the active playlist is stored in $$FILES{plname}.
     $$FILES{plname} is missing when main is active.

     This command deactivated the current active playlist,
       and activates main if PLNAME was activated, or else activates PLNAME.

     Activating a playlist named PLNAME means writing it to $$FILES{plname},
       and moving from $$FILES{pldir}PLNAME/ to $ENV{HOME}
     Deactivating a playlist named PLNAME means removing $$FILES{plname},
       and moving from $ENV{HOME}/ to $$FILES{pldir}PLNAME/

  $0 playlist-main - if a named playlist is set, unset it
  $0 start - start
  $0 stop - stop
  $0 restart - if klomplayer is running, stops and then starts
  $0 pause - play/pause
  $0 prev - previous song
  $0 next - skip song
  $0 seekabs [S|S.SS|PERCENT%] - seek to absolute seconds or percent of length
  $0 shuffle - shuffle klomplist randomly
  $0 breaks [on|off|toggle] - add/remove '!klomp-cmd stop's in klomplist
     {e.g.: for sleeping with a book and not losing more than a chapter}
     on: remove all stops, and place a stop after each song except the last
     off: remove all stops
     toggle: if any stops are present, same as off, else same as on
  $0 <mplayer slave input command>
     see: mplayer -input cmdlist
     for complete command list
     {e.g.: $0 seek 10}
";

sub isPhone();
sub getPid();
sub isRunning();
sub start(;$);
sub stop();
sub getNice($);
sub renice();
sub shellQuiet(@);
sub prevItem();
sub nextItem();
sub seekAbs($);
sub setKlompCurPos($);
sub setKlompCurPosPercent($);
sub getPosLen();
sub addCurTimestamp($);
sub removeCurTimestamp($);
sub toggleActivePlaylist($);
sub playlistPresent();
sub backupPlaylistFiles($);
sub restorePlaylistFiles($);
sub getActivePlaylistName();
sub setActivePlaylistName($);
sub setBreaks($);
sub lpsmagic();

if(isPhone and `whoami` =~ /^root(\n|$)/){
  print "you are root. rerunning as user\n";
  exec "su -c '$0 @ARGV' user";
}

sub main(@){
  my $cmd = shift() || '';
  if($cmd eq '-h'){
    print $usage;
    exit 0;
  }elsif($cmd eq 'playlist' and @_ == 0){
    print getActivePlaylistName() . "\n";
  }elsif($cmd eq 'playlist' and @_ == 1){
    stop();
    my $name = shift;
    if($name eq 'main' or $name !~ /^[a-zA-Z0-9_]+$/){
      die "Invalid playlist name: '$name'\n"
    }
    toggleActivePlaylist $name;
    lpsmagic() if isN9();
  }elsif($cmd eq 'playlist-main'){
    my $name = getActivePlaylistName;
    if(defined $name and $name ne "main"){
      system $0, 'playlist', $name;
    }
  }elsif($cmd eq 'start' and @_ == 0){
    stop;
    start;
  }elsif($cmd eq 'stop' and @_ == 0){
    stop;
  }elsif($cmd eq 'restart' and @_ == 0){
    if(isRunning()){
      stop;
      start 1;
    }
  }elsif($cmd eq 'pause' and @_ == 0){
    if(not isRunning()){
      stop;
      start;
    }else{
      if(isPhone()){
        stop;
      }else{
        system "echo pause > $$FILES{fifo}";
      }
    }
  }elsif($cmd eq 'prev' and @_ == 0){
    stop;
    start if prevItem();
  }elsif($cmd eq 'next' and @_ == 0){
    stop;
    start if nextItem();
  }elsif($cmd eq 'seekabs' and @_ == 1 and $_[0] =~ /^\d+(\.\d+)?%?$/){
    seekAbs($_[0]);
  }elsif($cmd eq 'shuffle' and @_ == 0){
    system "sort", "-R", $$FILES{list}, "-o", $$FILES{list};
  }elsif($cmd eq 'breaks' and @_ == 1){
    my $arg = shift;
    die "invalid argument to breaks\n" if $arg !~ /^(on|off|toggle)$/;
    setBreaks $arg;
  }else{
    my $okCmds = getAvailableInputCommands();
    if(defined $$okCmds{$cmd}){
      system "echo \"$cmd @_\" > $$FILES{fifo}";
    }else{
      die $usage;
    }
  }
}

sub toggleActivePlaylist($){
  my $name = shift;
  my $oldName = getActivePlaylistName;
  $name = 'main' if $oldName eq $name;

  backupPlaylistFiles "$$FILES{pldir}$oldName";
  restorePlaylistFiles "$$FILES{pldir}$name";
  setActivePlaylistName $name;

  system "rmdir $$FILES{pldir}* 2>/dev/null";
}
sub getActivePlaylistName(){
  my $name = `cat $$FILES{plname} 2>/dev/null`;
  chomp $name;
  $name = 'main' if $name eq '';
  return $name;
}
sub setActivePlaylistName($){
  my $name = shift;
  $name = 'main' if $name eq '';
  system "rm", "-f", $$FILES{plname};
  if($name ne "main"){
    open FH, "> $$FILES{plname}"
      or die "Couldn't write $$FILES{plname}\n";
    print FH "$name\n";
    close FH;
  }
}

sub playlistPresent(){
  return -e $$FILES{cur} or -e $$FILES{list} or -e $$FILES{history};
}

sub backupPlaylistFiles($){
  my $dir = shift;
  die "error: $dir already exists!\n" if -e $dir;
  system "mkdir", "-p", $dir;
  die "error: could not create $dir!\n" if not -e $dir;

  system "mv", "--no-clobber",
    $$FILES{cur}, $$FILES{list}, $$FILES{hist}, $dir;
  die "error: playlist still present!\n" if playlistPresent;
}
sub restorePlaylistFiles($){
  my $dir = shift;
  die "error: playlist exists and would be overridden!\n" if playlistPresent;
  if(-e $dir){
    system "mv --no-clobber $dir/* $dir/.* $ENV{HOME} 2>/dev/null";
    system "rmdir", $dir;
  }
  die "error: $dir still exists!\n" if -e $dir;
}

sub setBreaks($){
  my $arg = shift;
  my $breakLine = "!klomp-cmd stop\n";
  my @lines = `cat $$FILES{list} 2>/dev/null`;
  my @nonBreakLines = grep {$_ ne $breakLine} @lines;
  my @newLines;
  if($arg eq 'on' or ($arg eq 'toggle' and @nonBreakLines == @lines)){
    for my $line(@nonBreakLines){
      push @newLines, $breakLine;
      push @newLines, $line;
    }
  }else{
    @newLines = @nonBreakLines;
  }
  open FH, "> $$FILES{list}" or die "Couldn't write $$FILES{list}\n";
  print FH @newLines;
  close FH;
}

sub getAvailableInputCommands(){
  my %cmds;
  my $cmdlist = `mplayer -input cmdlist`;
  while($cmdlist =~ /^([a-z_]+)/mg){
    $cmds{$1} = 1;
  }
  return \%cmds;
}

sub isPhone(){
  return (isN9() or isN900()) ? 1 : 0;
}
sub isN9(){
  return hostname() =~ /n9$/ ? 1 : 0;
}
sub isN900(){
  return hostname() =~ /n900$/ ? 1 : 0;
}

sub getPid(){
  if(-e $$FILES{pidfile}){
    my $pid = `cat $$FILES{pidfile}`;
    chomp $pid;
    return $pid;
  }else{
    return undef;
  }
}

sub isRunning(){
  my $pid = getPid;
  if(defined $pid){
    system "kill", "-0", $pid;
    return $? == 0 ? 1 : 0;
  }else{
    return 0;
  }
}

sub removePause(){
  return if not -e $$FILES{cur};
  open FH, "< $$FILES{cur}";
  my @lines = <FH>;
  close FH;
  return if @lines == 0;

  $lines[0] =~ s/^([0-9.]+) ([0-9.]+) paused/$1 $2/;

  open FH, "> $$FILES{cur}";
  print FH @lines;
  close FH;
}

sub ensureKlompCur(){
  my @lines;
  if(-e $$FILES{cur}){
    open FH, "< $$FILES{cur}";
    @lines = <FH>;
    close FH;
  }

  nextItem() if @lines == 0;
}

sub start(;$){
  lpsmagic() if isN9();
  removePause() unless @_ > 0 and $_[0];
  ensureKlompCur();

  if(fork()){
    exec "$klomplayerExec >/dev/null 2>/dev/null &";
  }
  if(isN9()){
    sleep 1;
    renice();
  }
}

sub stop(){
  my $pid = getPid();
  if(defined $pid){
    system "kill", "-9", $pid;
    system "rm", $$FILES{pidfile};
  }
  system "killall -9 mplayer 2>/dev/null" if isPhone();
  system "rm -f /tmp/klomplayer*";
}

sub getNice($){
  my $pid = shift;
  my $ps = `ps -o pid,nice | grep $pid`;
  if($ps =~ /^\s*\d+\s*(-?\d+)$/){
    return $1;
  }
  return '?';
}

sub renice(){
  my $pid = getPid();
  if(defined $pid){
    my $oldNice = getNice($pid);
    system "sudo", "renice", "-n", "-12", $pid;
    my $newNice = getNice($pid);
    print "reniced $pid: $oldNice => $newNice\n";
  }else{
    print "Could not renice; klomplayer not running\n";
  }
}

sub wrapTokens(@){
  my @tokens;
  for my $token(@_){
    my $t = $token;
    $t =~ s/'/'\\''/g;
    push @tokens, "'$t'";
  }
  return @tokens;
}
sub shellQuiet(@){
  my $cmd = join ' ', wrapTokens(@_);
  return `$cmd 2>/dev/null`;
}
sub shell(@){
  my $cmd = join ' ', wrapTokens(@_);
  return `$cmd`;
}

sub popFile($){
  my $file = shift;
  if(not -e $file){
   return undef;
  }
  my @items = `cat $file`;
  if(@items == 0){
    return undef;
  }
  my $item = shift @items;

  open FH, "> $file";
  print FH @items;
  close FH;

  return $item;
}

sub pushFile($$){
  my $file = shift;
  my $item = shift;
  $item =~ s/\n*$/\n/;
  my @items = -e $file ? `cat $file` : ();
  @items = ($item, @items);
  open FH, "> $file";
  print FH @items;
  close FH;
}

sub getCur(){
  my $cur = -e $$FILES{cur} ? `cat $$FILES{cur}` : '';
  if($cur =~ /^[0-9\-\.]+ [0-9\-\.]+ (.*)$/s){
    my $item = $1;
    $item =~ s/\n+$//;
    chomp $item;
    $item =~ s/\n/\/\/\/\\\\\\/g;
    return $item;
  }else{
    return undef;
  }
}

sub setCur($){
  my $item = shift;
  if($item =~ /^!klomp-cmd (.*)$/si){
    print "running klomp-cmd: $1\n";
    system "$0 $1";
    system "rm", $$FILES{cur};
    return 0;
  }else{
    $item =~ s/\/\/\/\\\\\\/\n/g;
    chomp $item;
    open FH, "> $$FILES{cur}";
    print FH "0.0 0.0 $item\n";
    close FH;
    return 1;
  }
}

sub addCurTimestamp($){
  my $cur = shift;
  $cur = removeCurTimestamp $cur;
  my $timestamp = `date`;
  chomp $timestamp;
  return "$cur###$timestamp###";
}
sub removeCurTimestamp($){
  my $cur = shift;
  $cur =~ s/###.*###$//;
  return $cur;
}

sub prevnext($$){
  my $srcFile = shift;
  my $destFile = shift;

  my $oldCur = getCur;
  $oldCur = addCurTimestamp $oldCur if defined $oldCur;
  my $cur = popFile $srcFile;
  $cur = removeCurTimestamp $cur;
  if(defined $cur){
    if(defined $oldCur){
      pushFile $destFile, $oldCur;
    }
    return setCur $cur;
  }else{
    return 0;
  }
}

sub prevItem(){
  return prevnext $$FILES{hist}, $$FILES{list};
}

sub nextItem(){
  return prevnext $$FILES{list}, $$FILES{hist};
}

sub seekAbs($){
  my $wasRunning = isRunning();
  stop;
  my $s = shift;
  if($s =~ /^(\d+(?:\.\d+)?)%$/){
    setKlompCurPosPercent($1);
  }else{
    setKlompCurPos($s);
  }
  start(1) if $wasRunning;
}

sub setKlompCurPos($){
  return if not -e $$FILES{cur};
  my $pos = shift;
  $pos = sprintf "%.2f", $pos;

  open FH, "< $$FILES{cur}";
  my @lines = <FH>;
  close FH;
  return if @lines == 0;

  $lines[0] =~ s/^([0-9.]+) ([0-9.]+) /$pos $2 /;

  open FH, "> $$FILES{cur}";
  print FH @lines;
  close FH;
}
sub setKlompCurPosPercent($){
  my $per = shift;
  my ($pos, $len) = getPosLen();
  setKlompCurPos(($per/100) * $len);
}

sub getPosLen(){
  my $info = `klomp-info -s pos len`;
  if($info !~ /^(\d+(?:\.\d+)?) (\d+(?:\.\d+)?)$/){
    die "Error reading klomp-info\n";
  }
  my ($curPos, $curLen) = ($1, $2);
  die "Missing length info\n" if $curLen == 0;
  return ($curPos, $curLen);
}


sub lpsmagic(){
  system "(lpsmagic -once 2>&1 | grep 'Rendering format string') &";
}

&main(@ARGV);
