#!/usr/bin/perl
use strict;
use warnings;

sub qNext($);
sub qPrev($);

if(not fork){
  exec "~/q/qupdater &";
}

my $QCUR = `echo -n \$HOME/.qcur`;
my $QLIST = `echo -n \$HOME/.qlist`;
my $QHIST = `echo -n \$HOME/.qhistory`;

if(not -e $QCUR){
  die "$QCUR does not exist\n";
}

my $cur = `cat $QCUR`;
my $initPos;
my $len;
my $file;
if($cur =~ /^prev/){
  qPrev(undef);
  exec $0;
}
if($cur =~ /^next/){
  qNext(undef);
  exec $0;
}
if($cur !~ /^([0-9\.\-]+) ([0-9\.]+) (.*)/){
  die "Current file $QCUR malformed";
}
$initPos = $1;
$len = $2;
$file = $3;

my $PID_FILE = '/tmp/qmplayer_pid';
system "kill -9 `cat $PID_FILE` 2>/dev/null";

my $FIFO = '/tmp/qmplayer_fifo';
system "rm -f $FIFO";
system "mkfifo $FIFO";

my $pid = open FH, '-|',
  'mplayer',
  '-quiet',
  '-input', "file=$FIFO",
  '-ss', $initPos,
  $file;

system "echo $pid > $PID_FILE";

my $line = '';
while($line !~ /^Starting playback.../){
  $line = <FH>;
  if(not defined $line){
    die "Error starting mplayer\n";
  }
}

my $posLine;
my $lenLine;

sub update($$){
  my $pos = shift;
  my $len = shift;
  $pos =~ s/.*=([^\n]+)\n/$1/s;
  $len =~ s/.*=([^\n]+)\n/$1/s;
  my $cur = `cat $QCUR`;
  if($cur =~ /^next/){
    print "next signalled\n";
    qNext($file);
    exec $0;
  }elsif($cur =~ /^prev/){
    print "prev signalled\n";
    qPrev($file);
    exec $0;
  }
  open CURFILE, "> $QCUR";
  print CURFILE "$pos $len $file\n";
  close CURFILE;
}

while(1){
  my $newPid = `cat $PID_FILE`;
  chomp $newPid;
  if($newPid ne $pid){
    die "new $0 is running\n";
  }
  if(not -p $FIFO){
    die "fifo $FIFO is broken\n";
  }

  my $line = '';
  while($line !~ /^ANS_TIME_POSITION=/){
    $line = <FH>;
    print "$line";
    if(not defined $line){
      die "i guess its dead...\n";
    }
    if($line =~ /^Exiting... \(End of file\)/){
      qNext($file);
      exec $0;
    }
    if($line =~ /^ANS_LENGTH/){
      $lenLine = $line;
    }elsif($line =~ /^ANS_TIME_POSITION/){
      $posLine = $line;
    }
  }
  update $posLine, $lenLine;
}

sub popFile($){
  my $file = shift;
  if(not -e $file){
   return undef;
  }
  my @items = `cat $file`;
  if(@items == 0){
    return undef;
  }
  my $item = shift @items;

  open FH, "> $file";
  print FH @items;
  close FH;

  return $item;
}

sub pushFile($$){
  my $file = shift;
  my $item = shift;
  $item =~ s/\n*$/\n/;
  my @items = -e $file ? `cat $file` : ();
  @items = ($item, @items);
  open FH, "> $file";
  print FH @items;
  close FH;
}

sub setCur($){
  my $item = shift;
  open FH, "> $QCUR";
  print FH "0.0 0.0 $item";
  close FH;
}

sub prevnext($$$){
  my $srcFile = shift;
  my $destFile = shift;
  my $oldCur = shift;

  my $cur = popFile $srcFile;
  if(defined $cur){
    if(defined $oldCur and $oldCur !~ /^(next|prev)$/){
      pushFile $destFile, $oldCur;
    }
    setCur $cur;
  }
}

sub qNext($){
  my $oldCur = shift;
  prevnext $QLIST, $QHIST, $oldCur;
}

sub qPrev($){
  my $oldCur = shift;
  prevnext $QHIST, $QLIST, $oldCur;
}

